          audioBuffer = await this.textToSpeechGoogle(text, voice, language, format, speed, pitch);
          break;
        case 'azure':
          audioBuffer = await this.textToSpeechAzure(text, voice, language, format);
          break;
        default:
          throw new Error(`Provider ${provider} not supported`);
      }

      // Save to file
      const filename = `tts_${Date.now()}.${format}`;
      const filepath = path.join(process.env.AUDIO_PATH || './audio', filename);
      await fs.writeFile(filepath, audioBuffer);

      return {
        buffer: audioBuffer,
        filename,
        filepath,
        duration: await this.getAudioDuration(filepath)
      };
    } catch (error) {
      console.error('Text-to-speech error:', error);
      throw error;
    }
  }

  async textToSpeechPolly(text, voiceId, languageCode, outputFormat) {
    const params = {
      Text: text,
      VoiceId: voiceId,
      OutputFormat: outputFormat,
      LanguageCode: languageCode,
      Engine: 'neural' // Use neural voice for better quality
    };

    const result = await this.polly.synthesizeSpeech(params).promise();
    return result.AudioStream;
  }

  async textToSpeechGoogle(text, voice, language, format, speed, pitch) {
    const request = {
      input: { text },
      voice: {
        languageCode: language,
        name: `${language}-${voice}`,
        ssmlGender: 'FEMALE'
      },
      audioConfig: {
        audioEncoding: format.toUpperCase(),
        speakingRate: speed,
        pitch: pitch
      }
    };

    const [response] = await this.googleTTSClient.synthesizeSpeech(request);
    return response.audioContent;
  }

  async textToSpeechAzure(text, voice, language, format) {
    const sdk = require('microsoft-cognitiveservices-speech-sdk');
    
    return new Promise((resolve, reject) => {
      const audioConfig = sdk.AudioConfig.fromAudioFileOutput(`temp_${Date.now()}.wav`);
      const synthesizer = new sdk.SpeechSynthesizer(this.azureSpeechConfig, audioConfig);
      
      synthesizer.speakTextAsync(
        text,
        result => {
          if (result.reason === sdk.ResultReason.SynthesizingAudioCompleted) {
            resolve(result.audioData);
          } else {
            reject(new Error('Azure TTS failed'));
          }
          synthesizer.close();
        },
        error => {
          reject(error);
          synthesizer.close();
        }
      );
    });
  }

  // === SPEECH TO TEXT ===
  async speechToText(audioBuffer, options = {}) {
    const {
      provider = 'google',
      language = 'es-ES',
      alternatives = 1
    } = options;

    try {
      let transcript;
      
      switch (provider) {
        case 'google':
          transcript = await this.speechToTextGoogle(audioBuffer, language, alternatives);
          break;
        case 'aws':
          transcript = await this.speechToTextAWS(audioBuffer, language);
          break;
        case 'azure':
          transcript = await this.speechToTextAzure(audioBuffer, language);
          break;
        default:
          throw new Error(`Provider ${provider} not supported`);
      }

      return transcript;
    } catch (error) {
      console.error('Speech-to-text error:', error);
      throw error;
    }
  }

  async speechToTextGoogle(audioBuffer, language, maxAlternatives) {
    const audio = {
      content: audioBuffer.toString('base64')
    };

    const config = {
      encoding: 'OGG_OPUS',
      sampleRateHertz: 48000,
      languageCode: language,
      maxAlternatives: maxAlternatives,
      enableAutomaticPunctuation: true,
      model: 'latest_long'
    };

    const request = {
      audio: audio,
      config: config
    };

    const [response] = await this.googleSpeechClient.recognize(request);
    
    return {
      transcript: response.results[0]?.alternatives[0]?.transcript || '',
      confidence: response.results[0]?.alternatives[0]?.confidence || 0,
      alternatives: response.results[0]?.alternatives || []
    };
  }

  async speechToTextAWS(audioBuffer, language) {
    // Upload audio to S3 first
    const s3 = new AWS.S3();
    const bucketName = process.env.AWS_S3_BUCKET;
    const key = `audio/stt_${Date.now()}.ogg`;
    
    await s3.putObject({
      Bucket: bucketName,
      Key: key,
      Body: audioBuffer
    }).promise();

    // Start transcription job
    const params = {
      TranscriptionJobName: `job_${Date.now()}`,
      LanguageCode: language,
      MediaFormat: 'ogg',
      Media: {
        MediaFileUri: `s3://${bucketName}/${key}`
      }
    };

    const job = await this.transcribe.startTranscriptionJob(params).promise();
    
    // Wait for job completion (simplified - should use polling in production)
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    const result = await this.transcribe.getTranscriptionJob({
      TranscriptionJobName: job.TranscriptionJob.TranscriptionJobName
    }).promise();

    // Fetch transcript from S3
    const transcriptUri = result.TranscriptionJob.Transcript.TranscriptFileUri;
    // ... fetch and parse transcript

    return {
      transcript: 'Transcribed text here',
      confidence: 0.95
    };
  }

  // === VOICE PROCESSING ===
  async processVoiceMessage(audioPath, options = {}) {
    try {
      // Convert audio format if needed
      const convertedPath = await this.convertAudioFormat(audioPath, 'wav');
      
      // Read audio file
      const audioBuffer = await fs.readFile(convertedPath);
      
      // Transcribe audio
      const transcript = await this.speechToText(audioBuffer, options);
      
      // Analyze voice characteristics
      const analysis = await this.analyzeVoice(audioBuffer);
      
      return {
        transcript,
        analysis,
        originalPath: audioPath,
        processedPath: convertedPath
      };
    } catch (error) {
      console.error('Voice processing error:', error);
      throw error;
    }
  }

  async convertAudioFormat(inputPath, outputFormat) {
    const outputPath = inputPath.replace(/\.[^.]+$/, `.${outputFormat}`);
    
    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .toFormat(outputFormat)
        .on('end', () => resolve(outputPath))
        .on('error', reject)
        .save(outputPath);
    });
  }

  async getAudioDuration(audioPath) {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(audioPath, (err, metadata) => {
        if (err) reject(err);
        else resolve(metadata.format.duration);
      });
    });
  }

  async analyzeVoice(audioBuffer) {
    // Analyze voice characteristics
    // This could include emotion detection, speaker identification, etc.
    return {
      emotion: 'neutral',
      gender: 'unknown',
      age: 'adult',
      language: 'es',
      quality: 'good'
    };
  }

  // === VOICE BOT RESPONSES ===
  async generateVoiceResponse(text, conversationId, options = {}) {
    try {
      // Generate audio from text
      const audio = await this.textToSpeech(text, options);
      
      // Save to conversation history
      await this.saveVoiceMessage(conversationId, {
        type: 'bot',
        text: text,
        audioPath: audio.filepath,
        duration: audio.duration
      });

      return audio;
    } catch (error) {
      console.error('Voice response generation error:', error);
      throw error;
    }
  }

  async saveVoiceMessage(conversationId, messageData) {
    // Save voice message to database
    const Conversation = require('../models/Conversation');
    
    await Conversation.findByIdAndUpdate(
      conversationId,
      {
        $push: {
          messages: {
            ...messageData,
            timestamp: new Date()
          }
        }
      }
    );
  }

  // === VOICE COMMANDS ===
  async processVoiceCommand(audioBuffer, botId) {
    try {
      // Transcribe audio
      const { transcript } = await this.speechToText(audioBuffer);
      
      // Detect intent
      const nlpService = require('./nlpService');
      const intent = await nlpService.detectIntent(botId, transcript, 'voice-session');
      
      // Generate response
      let response = 'No entendí tu comando';
      
      if (intent.intent && intent.confidence > 0.7) {
        // Process command based on intent
        response = await this.executeVoiceCommand(intent);
      }

      // Convert response to speech
      const voiceResponse = await this.textToSpeech(response);
      
      return {
        command: transcript,
        intent: intent,
        response: response,
        audio: voiceResponse
      };
    } catch (error) {
      console.error('Voice command processing error:', error);
      throw error;
    }
  }

  async executeVoiceCommand(intent) {
    // Execute command based on intent
    switch (intent.intent) {
      case 'check_balance':
        return 'Tu saldo actual es de 500 dólares';
      case 'make_appointment':
        return 'He agendado tu cita para mañana a las 3 PM';
      case 'order_status':
        return 'Tu pedido está en camino y llegará mañana';
      default:
        return 'Comando ejecutado correctamente';
    }
  }

  // === VOICE ANALYTICS ===
  async getVoiceAnalytics(botId, period = 'month') {
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - 1);

    const Conversation = require('../models/Conversation');
    
    const conversations = await Conversation.find({
      botId,
      'messages.type': { $in: ['audio', 'voice'] },
      createdAt: { $gte: startDate }
    });

    const stats = {
      totalVoiceMessages: 0,
      totalDuration: 0,
      avgDuration: 0,
      languages: {},
      emotions: {},
      transcriptionAccuracy: []
    };

    conversations.forEach(conv => {
      conv.messages.forEach(msg => {
        if (msg.type === 'audio' || msg.type === 'voice') {
          stats.totalVoiceMessages++;
          stats.totalDuration += msg.duration || 0;
          
          if (msg.language) {
            stats.languages[msg.language] = (stats.languages[msg.language] || 0) + 1;
          }
          
          if (msg.emotion) {
            stats.emotions[msg.emotion] = (stats.emotions[msg.emotion] || 0) + 1;
          }
          
          if (msg.confidence) {
            stats.transcriptionAccuracy.push(msg.confidence);
          }
        }
      });
    });

    stats.avgDuration = stats.totalVoiceMessages > 0 
      ? stats.totalDuration / stats.totalVoiceMessages 
      : 0;
    
    stats.avgAccuracy = stats.transcriptionAccuracy.length > 0
      ? stats.transcriptionAccuracy.reduce((a, b) => a + b, 0) / stats.transcriptionAccuracy.length
      : 0;

    return stats;
  }
}

module.exports = new VoiceService();
```

## 📦 ACTUALIZACIÓN DE PAQUETES

### backend/package.json (actualización final)

```json
{
  "name": "botbuilder-backend",
  "version": "3.0.0",
  "description": "Ultimate BotBuilder Platform with ML, i18n, Marketplace, CRM & Voice",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "worker": "node workers/webhookWorker.js",
    "train-ml": "node scripts/trainML.js"
  },
  "dependencies": {
    "@google-cloud/dialogflow": "^5.5.0",
    "@google-cloud/speech": "^6.0.0",
    "@google-cloud/text-to-speech": "^5.0.0",
    "@google-cloud/translate": "^8.0.0",
    "@hubspot/api-client": "^9.1.0",
    "@paypal/checkout-server-sdk": "^1.0.3",
    "@whiskeysockets/baileys": "^6.5.0",
    "aws-sdk": "^2.1500.0",
    "bcryptjs": "^2.4.3",
    "bull": "^4.11.5",
    "cors": "^2.8.5",
    "date-fns": "^3.0.6",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-validator": "^7.0.1",
    "ffmpeg-fluent": "^2.1.2",
    "franc": "^6.1.0",
    "ioredis": "^5.3.2",
    "jsforce": "^2.0.0",
    "jsonwebtoken": "^9.0.2",
    "jszip": "^3.10.1",
    "microsoft-cognitiveservices-speech-sdk": "^1.34.0",
    "moment": "^2.29.4",
    "mongoose": "^8.0.3",
    "multer": "^1.4.5-lts.1",
    "natural": "^6.10.0",
    "node-wit": "^6.0.1",
    "nodemailer": "^6.9.7",
    "openai": "^4.24.1",
    "pino": "^8.17.2",
    "qrcode": "^1.5.3",
    "socket.io": "^4.6.1",
    "stripe": "^14.10.0",
    "twilio": "^4.19.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

### frontend/package.json (actualización final)

```json
{
  "name": "botbuilder-frontend",
  "version": "3.0.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.15.3",
    "@mui/material": "^5.15.3",
    "@mui/x-data-grid": "^6.18.7",
    "@paypal/react-paypal-js": "^8.1.3",
    "@stripe/react-stripe-js": "^2.4.0",
    "@stripe/stripe-js": "^2.2.2",
    "axios": "^1.6.5",
    "date-fns": "^3.0.6",
    "i18next": "^23.7.16",
    "i18next-browser-languagedetector": "^7.2.0",
    "i18next-http-backend": "^2.4.2",
    "react": "^18.2.0",
    "react-audio-player": "^0.17.0",
    "react-beautiful-dnd": "^13.1.1",
    "react-dom": "^18.2.0",
    "react-dropzone": "^14.2.3",
    "react-flow-renderer": "^10.3.17",
    "react-i18next": "^14.0.0",
    "react-mic": "^12.4.6",
    "react-qr-code": "^2.0.12",
    "react-router-dom": "^6.21.1",
    "react-scripts": "5.0.1",
    "react-select": "^5.8.0",
    "recharts": "^2.10.4",
    "socket.io-client": "^4.6.1",
    "wavesurfer.js": "^7.6.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

## 📦 VARIABLES DE ENTORNO COMPLETAS

```env
# === BÁSICAS ===
NODE_ENV=production
MONGO_USER=admin
MONGO_PASSWORD=secretpass
REDIS_PASSWORD=redispass
JWT_SECRET=your-super-secret-jwt-key

# === EMAIL ===
EMAIL_SERVICE=gmail
EMAIL_USER=your-email@gmail.com
EMAIL_PASSWORD=your-app-password
EMAIL_FROM=BotBuilder <your-email@gmail.com>

# === SMS ===
TWILIO_ACCOUNT_SID=your-twilio-sid
TWILIO_AUTH_TOKEN=your-twilio-token
TWILIO_PHONE_NUMBER=+1234567890

# === AI / NLP ===
OPENAI_API_KEY=your-openai-key
DIALOGFLOW_PROJECT_ID=your-project-id
DIALOGFLOW_KEY_PATH=./keys/dialogflow.json
WIT_AI_TOKEN=your-wit-token
LUIS_ENDPOINT=https://your-luis.cognitiveservices.azure.com
LUIS_KEY=your-luis-key

# === TRADUCCIÓN ===
GOOGLE_TRANSLATE_KEY=your-google-translate-key
AZURE_TRANSLATOR_KEY=your-azure-key
AZURE_TRANSLATOR_REGION=eastus
DEEPL_API_KEY=your-deepl-key

# === MARKETPLACE / PAGOS ===
STRIPE_SECRET_KEY=sk_live_xxxxx
STRIPE_PUBLISHABLE_KEY=pk_live_xxxxx
PAYPAL_CLIENT_ID=your-paypal-client-id
PAYPAL_CLIENT_SECRET=your-paypal-secret

# === CRM ===
SALESFORCE_USERNAME=your-sf-username
SALESFORCE_PASSWORD=your-sf-password
SALESFORCE_TOKEN=your-sf-token
SALESFORCE_LOGIN_URL=https://login.salesforce.com

HUBSPOT_API_KEY=your-hubspot-key

PIPEDRIVE_API_TOKEN=your-pipedrive-token

ZOHO_CLIENT_ID=your-zoho-client-id
ZOHO_CLIENT_SECRET=your-zoho-secret
ZOHO_REFRESH_TOKEN=your-zoho-refresh-token

# === VOZ ===
AWS_ACCESS_KEY_ID=your-aws-access-key
AWS_SECRET_ACCESS_KEY=your-aws-secret
AWS_REGION=us-east-1
AWS_S3_BUCKET=botbuilder-audio

GOOGLE_CLOUD_SPEECH_KEY=./keys/google-speech.json

AZURE_SPEECH_KEY=your-azure-speech-key
AZURE_SPEECH_REGION=eastus

# === PATHS ===
SESSION_PATH=./sessions
AUDIO_PATH=./audio
UPLOAD_PATH=./uploads
```    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  status: {
    type: String,
    enum: ['draft', 'pending', 'approved', 'rejected', 'suspended'],
    default: 'draft'
  },
  featured: {
    type: Boolean,
    default: false
  },
  content: {
    flowData: mongoose.Schema.Types.Mixed,
    templateData: mongoose.Schema.Types.Mixed,
    documentationUrl: String,
    supportUrl: String,
    version: String,
    changelog: String
  },
  seo: {
    metaTitle: String,
    metaDescription: String,
    keywords: [String],
    slug: {
      type: String,
      unique: true
    }
  },
  publishedAt: Date,
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
marketplaceItemSchema.index({ seller: 1, status: 1 });
marketplaceItemSchema.index({ category: 1, 'stats.rating.average': -1 });
marketplaceItemSchema.index({ 'pricing.model': 1, 'pricing.price': 1 });
marketplaceItemSchema.index({ 'seo.slug': 1 });
marketplaceItemSchema.index({ tags: 1 });
marketplaceItemSchema.index({ '$**': 'text' }); // Full text search

module.exports = mongoose.model('MarketplaceItem', marketplaceItemSchema);
```

### 📦 backend/models/Purchase.js

```javascript
const mongoose = require('mongoose');

const purchaseSchema = new mongoose.Schema({
  buyer: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  seller: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  item: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'MarketplaceItem',
    required: true
  },
  pricing: {
    amount: {
      type: Number,
      required: true
    },
    currency: {
      type: String,
      default: 'USD'
    },
    commission: {
      type: Number,
      required: true
    },
    sellerRevenue: {
      type: Number,
      required: true
    }
  },
  payment: {
    method: {
      type: String,
      enum: ['stripe', 'paypal', 'crypto', 'credit'],
      required: true
    },
    transactionId: String,
    status: {
      type: String,
      enum: ['pending', 'completed', 'failed', 'refunded'],
      default: 'pending'
    },
    receiptUrl: String
  },
  subscription: {
    isSubscription: {
      type: Boolean,
      default: false
    },
    subscriptionId: String,
    currentPeriodEnd: Date,
    cancelledAt: Date,
    status: {
      type: String,
      enum: ['active', 'cancelled', 'expired', 'trial']
    }
  },
  license: {
    key: {
      type: String,
      unique: true,
      sparse: true
    },
    activations: [{
      domain: String,
      ip: String,
      activatedAt: Date
    }],
    maxActivations: {
      type: Number,
      default: 1
    }
  },
  downloadCount: {
    type: Number,
    default: 0
  },
  lastDownloadAt: Date,
  refund: {
    requested: {
      type: Boolean,
      default: false
    },
    requestedAt: Date,
    reason: String,
    approved: Boolean,
    processedAt: Date
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Generate license key
purchaseSchema.pre('save', function(next) {
  if (!this.license.key) {
    const crypto = require('crypto');
    this.license.key = crypto.randomBytes(16).toString('hex').toUpperCase();
  }
  next();
});

// Indexes
purchaseSchema.index({ buyer: 1, item: 1 });
purchaseSchema.index({ seller: 1, 'payment.status': 1 });
purchaseSchema.index({ 'license.key': 1 });

module.exports = mongoose.model('Purchase', purchaseSchema);
```

### 📦 backend/services/marketplaceService.js

```javascript
const MarketplaceItem = require('../models/MarketplaceItem');
const Purchase = require('../models/Purchase');
const User = require('../models/User');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const paypal = require('@paypal/checkout-server-sdk');

class MarketplaceService {
  constructor() {
    this.initializePaymentProviders();
  }

  initializePaymentProviders() {
    // Stripe
    this.stripe = stripe;

    // PayPal
    if (process.env.PAYPAL_CLIENT_ID) {
      const environment = process.env.NODE_ENV === 'production'
        ? new paypal.core.LiveEnvironment(
            process.env.PAYPAL_CLIENT_ID,
            process.env.PAYPAL_CLIENT_SECRET
          )
        : new paypal.core.SandboxEnvironment(
            process.env.PAYPAL_CLIENT_ID,
            process.env.PAYPAL_CLIENT_SECRET
          );
      
      this.paypalClient = new paypal.core.PayPalHttpClient(environment);
    }
  }

  // Create marketplace listing
  async createListing(sellerId, itemData) {
    try {
      // Generate SEO-friendly slug
      const slug = this.generateSlug(itemData.title);

      const item = new MarketplaceItem({
        ...itemData,
        seller: sellerId,
        'seo.slug': slug,
        status: 'pending' // Requires admin approval
      });

      await item.save();

      // Notify admins for review
      await this.notifyAdminsForReview(item);

      return item;
    } catch (error) {
      console.error('Error creating listing:', error);
      throw error;
    }
  }

  // Process purchase
  async processPurchase(buyerId, itemId, paymentMethod, paymentDetails) {
    try {
      const item = await MarketplaceItem.findById(itemId).populate('seller');
      
      if (!item) {
        throw new Error('Item not found');
      }

      // Calculate amounts
      const amount = item.pricing.price;
      const commission = amount * item.pricing.commission;
      const sellerRevenue = amount - commission;

      // Create purchase record
      const purchase = new Purchase({
        buyer: buyerId,
        seller: item.seller._id,
        item: itemId,
        pricing: {
          amount,
          currency: item.pricing.currency,
          commission,
          sellerRevenue
        },
        payment: {
          method: paymentMethod,
          status: 'pending'
        }
      });

      // Process payment
      let paymentResult;
      
      if (paymentMethod === 'stripe') {
        paymentResult = await this.processStripePayment(amount, item.pricing.currency, paymentDetails);
      } else if (paymentMethod === 'paypal') {
        paymentResult = await this.processPayPalPayment(amount, item.pricing.currency, paymentDetails);
      }

      // Update purchase with payment result
      purchase.payment.transactionId = paymentResult.transactionId;
      purchase.payment.status = paymentResult.status;
      purchase.payment.receiptUrl = paymentResult.receiptUrl;

      await purchase.save();

      // Update item stats
      await MarketplaceItem.findByIdAndUpdate(itemId, {
        $inc: { 
          'stats.downloads': 1,
          'stats.revenue.total': sellerRevenue
        }
      });

      // Credit seller account
      await this.creditSellerAccount(item.seller._id, sellerRevenue);

      // Send confirmation emails
      await this.sendPurchaseConfirmation(purchase);

      return purchase;
    } catch (error) {
      console.error('Error processing purchase:', error);
      throw error;
    }
  }

  // Process Stripe payment
  async processStripePayment(amount, currency, paymentDetails) {
    try {
      const paymentIntent = await this.stripe.paymentIntents.create({
        amount: amount * 100, // Convert to cents
        currency: currency.toLowerCase(),
        payment_method: paymentDetails.paymentMethodId,
        confirm: true,
        metadata: {
          platform: 'botbuilder-marketplace'
        }
      });

      return {
        transactionId: paymentIntent.id,
        status: paymentIntent.status === 'succeeded' ? 'completed' : 'pending',
        receiptUrl: paymentIntent.charges.data[0]?.receipt_url
      };
    } catch (error) {
      console.error('Stripe payment error:', error);
      throw error;
    }
  }

  // Process PayPal payment
  async processPayPalPayment(amount, currency, paymentDetails) {
    try {
      const request = new paypal.orders.OrdersCaptureRequest(paymentDetails.orderId);
      const capture = await this.paypalClient.execute(request);

      return {
        transactionId: capture.result.id,
        status: capture.result.status === 'COMPLETED' ? 'completed' : 'pending',
        receiptUrl: capture.result.links.find(link => link.rel === 'self')?.href
      };
    } catch (error) {
      console.error('PayPal payment error:', error);
      throw error;
    }
  }

  // Create subscription
  async createSubscription(buyerId, itemId, paymentMethod) {
    try {
      const item = await MarketplaceItem.findById(itemId);
      
      if (item.pricing.model !== 'subscription') {
        throw new Error('Item is not subscription-based');
      }

      let subscription;
      
      if (paymentMethod === 'stripe') {
        // Create Stripe subscription
        const customer = await this.stripe.customers.create({
          metadata: { userId: buyerId }
        });

        const price = await this.stripe.prices.create({
          unit_amount: item.pricing.price * 100,
          currency: item.pricing.currency.toLowerCase(),
          recurring: {
            interval: item.pricing.subscription.interval
          },
          product_data: {
            name: item.title
          }
        });

        subscription = await this.stripe.subscriptions.create({
          customer: customer.id,
          items: [{ price: price.id }],
          trial_period_days: item.pricing.subscription.trialDays
        });
      }

      // Create purchase record with subscription
      const purchase = new Purchase({
        buyer: buyerId,
        seller: item.seller,
        item: itemId,
        pricing: {
          amount: item.pricing.price,
          currency: item.pricing.currency,
          commission: item.pricing.price * item.pricing.commission,
          sellerRevenue: item.pricing.price * (1 - item.pricing.commission)
        },
        payment: {
          method: paymentMethod,
          status: 'completed'
        },
        subscription: {
          isSubscription: true,
          subscriptionId: subscription.id,
          currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          status: 'active'
        }
      });

      await purchase.save();
      return purchase;
    } catch (error) {
      console.error('Error creating subscription:', error);
      throw error;
    }
  }

  // Search marketplace
  async searchMarketplace(query, filters = {}) {
    try {
      const searchQuery = {
        status: 'approved'
      };

      // Text search
      if (query) {
        searchQuery.$text = { $search: query };
      }

      // Apply filters
      if (filters.category) {
        searchQuery.category = filters.category;
      }
      
      if (filters.priceMin !== undefined || filters.priceMax !== undefined) {
        searchQuery['pricing.price'] = {};
        if (filters.priceMin !== undefined) {
          searchQuery['pricing.price'].$gte = filters.priceMin;
        }
        if (filters.priceMax !== undefined) {
          searchQuery['pricing.price'].$lte = filters.priceMax;
        }
      }

      if (filters.rating) {
        searchQuery['stats.rating.average'] = { $gte: filters.rating };
      }

      if (filters.pricingModel) {
        searchQuery['pricing.model'] = filters.pricingModel;
      }

      // Sort options
      let sortOptions = {};
      switch (filters.sortBy) {
        case 'popular':
          sortOptions = { 'stats.downloads': -1 };
          break;
        case 'rating':
          sortOptions = { 'stats.rating.average': -1 };
          break;
        case 'price-low':
          sortOptions = { 'pricing.price': 1 };
          break;
        case 'price-high':
          sortOptions = { 'pricing.price': -1 };
          break;
        case 'newest':
        default:
          sortOptions = { publishedAt: -1 };
      }

      const items = await MarketplaceItem.find(searchQuery)
        .populate('seller', 'name avatar')
        .sort(sortOptions)
        .limit(filters.limit || 20)
        .skip(filters.offset || 0);

      const total = await MarketplaceItem.countDocuments(searchQuery);

      return {
        items,
        total,
        page: Math.floor((filters.offset || 0) / (filters.limit || 20)) + 1,
        pages: Math.ceil(total / (filters.limit || 20))
      };
    } catch (error) {
      console.error('Error searching marketplace:', error);
      throw error;
    }
  }

  // Get seller analytics
  async getSellerAnalytics(sellerId, period = 'month') {
    try {
      const startDate = this.getStartDate(period);
      
      const [items, purchases, revenue] = await Promise.all([
        MarketplaceItem.find({ seller: sellerId }),
        Purchase.find({
          seller: sellerId,
          'payment.status': 'completed',
          createdAt: { $gte: startDate }
        }),
        Purchase.aggregate([
          {
            $match: {
              seller: mongoose.Types.ObjectId(sellerId),
              'payment.status': 'completed',
              createdAt: { $gte: startDate }
            }
          },
          {
            $group: {
              _id: null,
              total: { $sum: '$pricing.sellerRevenue' },
              count: { $sum: 1 }
            }
          }
        ])
      ]);

      // Calculate metrics
      const totalDownloads = items.reduce((sum, item) => sum + item.stats.downloads, 0);
      const avgRating = items.reduce((sum, item) => sum + item.stats.rating.average, 0) / items.length;

      return {
        items: items.length,
        totalDownloads,
        avgRating,
        revenue: revenue[0]?.total || 0,
        sales: revenue[0]?.count || 0,
        topItems: items
          .sort((a, b) => b.stats.downloads - a.stats.downloads)
          .slice(0, 5),
        recentPurchases: purchases.slice(0, 10)
      };
    } catch (error) {
      console.error('Error getting seller analytics:', error);
      throw error;
    }
  }

  // Helper functions
  generateSlug(title) {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  getStartDate(period) {
    const now = new Date();
    switch (period) {
      case 'day':
        return new Date(now - 24 * 60 * 60 * 1000);
      case 'week':
        return new Date(now - 7 * 24 * 60 * 60 * 1000);
      case 'month':
        return new Date(now - 30 * 24 * 60 * 60 * 1000);
      case 'year':
        return new Date(now - 365 * 24 * 60 * 60 * 1000);
      default:
        return new Date(now - 30 * 24 * 60 * 60 * 1000);
    }
  }

  async creditSellerAccount(sellerId, amount) {
    // Implementation for crediting seller's account
    await User.findByIdAndUpdate(sellerId, {
      $inc: { 'wallet.balance': amount }
    });
  }

  async sendPurchaseConfirmation(purchase) {
    // Send email confirmation
    // Implementation depends on email service
  }

  async notifyAdminsForReview(item) {
    // Notify admins about new listing
    // Implementation depends on notification system
  }
}

module.exports = new MarketplaceService();
```

## 4️⃣ CRM INTEGRATION

### 📦 backend/services/crmService.js

```javascript
const axios = require('axios');
const jsforce = require('jsforce');
const HubspotClient = require('@hubspot/api-client');

class CRMService {
  constructor() {
    this.initializeConnections();
  }

  initializeConnections() {
    // Salesforce
    if (process.env.SALESFORCE_USERNAME) {
      this.salesforce = new jsforce.Connection({
        loginUrl: process.env.SALESFORCE_LOGIN_URL || 'https://login.salesforce.com'
      });
      
      this.salesforce.login(
        process.env.SALESFORCE_USERNAME,
        process.env.SALESFORCE_PASSWORD + process.env.SALESFORCE_TOKEN
      ).catch(console.error);
    }

    // HubSpot
    if (process.env.HUBSPOT_API_KEY) {
      this.hubspot = new HubspotClient.Client({
        accessToken: process.env.HUBSPOT_API_KEY
      });
    }

    // Pipedrive
    if (process.env.PIPEDRIVE_API_TOKEN) {
      this.pipedriveApiUrl = `https://api.pipedrive.com/v1`;
      this.pipedriveToken = process.env.PIPEDRIVE_API_TOKEN;
    }

    // Zoho CRM
    if (process.env.ZOHO_CLIENT_ID) {
      this.zohoConfig = {
        clientId: process.env.ZOHO_CLIENT_ID,
        clientSecret: process.env.ZOHO_CLIENT_SECRET,
        refreshToken: process.env.ZOHO_REFRESH_TOKEN
      };
    }
  }

  // === SALESFORCE ===
  async createSalesforceContact(contactData) {
    try {
      const result = await this.salesforce.sobject('Contact').create({
        FirstName: contactData.firstName,
        LastName: contactData.lastName,
        Email: contactData.email,
        Phone: contactData.phone,
        LeadSource: 'WhatsApp Bot',
        Description: `Created from WhatsApp conversation on ${new Date().toISOString()}`
      });

      return { success: true, id: result.id, provider: 'salesforce' };
    } catch (error) {
      console.error('Salesforce contact creation error:', error);
      throw error;
    }
  }

  async createSalesforceLead(leadData) {
    try {
      const result = await this.salesforce.sobject('Lead').create({
        FirstName: leadData.firstName,
        LastName: leadData.lastName,
        Company: leadData.company || 'Unknown',
        Email: leadData.email,
        Phone: leadData.phone,
        Status: 'New',
        LeadSource: 'WhatsApp Bot',
        Rating: leadData.rating || 'Warm',
        Description: leadData.description
      });

      return { success: true, id: result.id, provider: 'salesforce' };
    } catch (error) {
      console.error('Salesforce lead creation error:', error);
      throw error;
    }
  }

  async createSalesforceOpportunity(oppData) {
    try {
      const result = await this.salesforce.sobject('Opportunity').create({
        Name: oppData.name,
        StageName: oppData.stage || 'Prospecting',
        CloseDate: oppData.closeDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        Amount: oppData.amount,
        Probability: oppData.probability || 10,
        LeadSource: 'WhatsApp Bot',
        Description: oppData.description
      });

      return { success: true, id: result.id, provider: 'salesforce' };
    } catch (error) {
      console.error('Salesforce opportunity creation error:', error);
      throw error;
    }
  }

  async updateSalesforceRecord(objectType, recordId, updates) {
    try {
      const result = await this.salesforce.sobject(objectType).update({
        Id: recordId,
        ...updates
      });

      return { success: result.success, provider: 'salesforce' };
    } catch (error) {
      console.error('Salesforce update error:', error);
      throw error;
    }
  }

  // === HUBSPOT ===
  async createHubSpotContact(contactData) {
    try {
      const contactObj = {
        properties: {
          firstname: contactData.firstName,
          lastname: contactData.lastName,
          email: contactData.email,
          phone: contactData.phone,
          hs_lead_status: 'NEW',
          lifecyclestage: 'lead',
          whatsapp_number: contactData.whatsappNumber
        }
      };

      const response = await this.hubspot.crm.contacts.basicApi.create(contactObj);
      
      return { success: true, id: response.id, provider: 'hubspot' };
    } catch (error) {
      console.error('HubSpot contact creation error:', error);
      throw error;
    }
  }

  async createHubSpotDeal(dealData) {
    try {
      const dealObj = {
        properties: {
          dealname: dealData.name,
          pipeline: dealData.pipeline || 'default',
          dealstage: dealData.stage || 'appointmentscheduled',
          amount: dealData.amount,
          closedate: dealData.closeDate,
          hs_priority: dealData.priority || 'medium'
        }
      };

      const response = await this.hubspot.crm.deals.basicApi.create(dealObj);
      
      return { success: true, id: response.id, provider: 'hubspot' };
    } catch (error) {
      console.error('HubSpot deal creation error:', error);
      throw error;
    }
  }

  async addHubSpotNote(contactId, note) {
    try {
      const noteObj = {
        properties: {
          hs_timestamp: Date.now(),
          hs_note_body: note
        }
      };

      const response = await this.hubspot.crm.objects.notes.basicApi.create(noteObj);
      
      // Associate note with contact
      await this.hubspot.crm.objects.associations.batchApi.create(
        'notes',
        'contacts',
        {
          inputs: [{
            from: { id: response.id },
            to: { id: contactId },
            type: 'note_to_contact'
          }]
        }
      );

      return { success: true, id: response.id, provider: 'hubspot' };
    } catch (error) {
      console.error('HubSpot note creation error:', error);
      throw error;
    }
  }

  // === PIPEDRIVE ===
  async createPipedriveContact(contactData) {
    try {
      const response = await axios.post(
        `${this.pipedriveApiUrl}/persons`,
        {
          name: `${contactData.firstName} ${contactData.lastName}`,
          email: contactData.email,
          phone: contactData.phone,
          visible_to: '3' // Everyone
        },
        {
          params: { api_token: this.pipedriveToken }
        }
      );

      return { success: true, id: response.data.data.id, provider: 'pipedrive' };
    } catch (error) {
      console.error('Pipedrive contact creation error:', error);
      throw error;
    }
  }

  async createPipedriveDeal(dealData) {
    try {
      const response = await axios.post(
        `${this.pipedriveApiUrl}/deals`,
        {
          title: dealData.title,
          value: dealData.value,
          currency: dealData.currency || 'USD',
          person_id: dealData.personId,
          stage_id: dealData.stageId || 1,
          status: 'open',
          visible_to: '3'
        },
        {
          params: { api_token: this.pipedriveToken }
        }
      );

      return { success: true, id: response.data.data.id, provider: 'pipedrive' };
    } catch (error) {
      console.error('Pipedrive deal creation error:', error);
      throw error;
    }
  }

  async addPipedriveActivity(activityData) {
    try {
      const response = await axios.post(
        `${this.pipedriveApiUrl}/activities`,
        {
          subject: activityData.subject,
          type: activityData.type || 'call',
          person_id: activityData.personId,
          deal_id: activityData.dealId,
          due_date: activityData.dueDate,
          due_time: activityData.dueTime,
          duration: activityData.duration,
          note: activityData.note
        },
        {
          params: { api_token: this.pipedriveToken }
        }
      );

      return { success: true, id: response.data.data.id, provider: 'pipedrive' };
    } catch (error) {
      console.error('Pipedrive activity creation error:', error);
      throw error;
    }
  }

  // === UNIFIED INTERFACE ===
  async syncContact(crmProvider, contactData) {
    switch (crmProvider) {
      case 'salesforce':
        return await this.createSalesforceContact(contactData);
      case 'hubspot':
        return await this.createHubSpotContact(contactData);
      case 'pipedrive':
        return await this.createPipedriveContact(contactData);
      default:
        throw new Error(`CRM provider ${crmProvider} not supported`);
    }
  }

  async syncDeal(crmProvider, dealData) {
    switch (crmProvider) {
      case 'salesforce':
        return await this.createSalesforceOpportunity(dealData);
      case 'hubspot':
        return await this.createHubSpotDeal(dealData);
      case 'pipedrive':
        return await this.createPipedriveDeal(dealData);
      default:
        throw new Error(`CRM provider ${crmProvider} not supported`);
    }
  }

  // Webhook handlers for CRM events
  async handleCRMWebhook(provider, event, data) {
    console.log(`Received ${provider} webhook:`, event);
    
    // Process webhook based on provider and event type
    switch (provider) {
      case 'salesforce':
        return this.handleSalesforceWebhook(event, data);
      case 'hubspot':
        return this.handleHubSpotWebhook(event, data);
      case 'pipedrive':
        return this.handlePipedriveWebhook(event, data);
      default:
        console.warn(`Unknown CRM provider: ${provider}`);
    }
  }

  async handleSalesforceWebhook(event, data) {
    // Process Salesforce webhook
    // Update local database, trigger workflows, etc.
  }

  async handleHubSpotWebhook(event, data) {
    // Process HubSpot webhook
  }

  async handlePipedriveWebhook(event, data) {
    // Process Pipedrive webhook
  }
}

module.exports = new CRMService();
```

## 5️⃣ VOICE ASSISTANT

### 📦 backend/services/voiceService.js

```javascript
const AWS = require('aws-sdk');
const { SpeechClient } = require('@google-cloud/speech');
const { TextToSpeechClient } = require('@google-cloud/text-to-speech');
const fs = require('fs').promises;
const path = require('path');
const ffmpeg = require('fluent-ffmpeg');

class VoiceService {
  constructor() {
    this.initializeProviders();
  }

  initializeProviders() {
    // AWS Polly (Text-to-Speech)
    if (process.env.AWS_ACCESS_KEY_ID) {
      AWS.config.update({
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
        region: process.env.AWS_REGION || 'us-east-1'
      });
      
      this.polly = new AWS.Polly();
      this.transcribe = new AWS.TranscribeService();
    }

    // Google Cloud Speech
    if (process.env.GOOGLE_CLOUD_SPEECH_KEY) {
      this.googleSpeechClient = new SpeechClient({
        keyFilename: process.env.GOOGLE_CLOUD_SPEECH_KEY
      });
      
      this.googleTTSClient = new TextToSpeechClient({
        keyFilename: process.env.GOOGLE_CLOUD_SPEECH_KEY
      });
    }

    // Azure Speech Services
    if (process.env.AZURE_SPEECH_KEY) {
      const sdk = require('microsoft-cognitiveservices-speech-sdk');
      this.azureSpeechConfig = sdk.SpeechConfig.fromSubscription(
        process.env.AZURE_SPEECH_KEY,
        process.env.AZURE_SPEECH_REGION
      );
    }
  }

  // === TEXT TO SPEECH ===
  async textToSpeech(text, options = {}) {
    const {
      provider = 'polly',
      voice = 'Mia', // Spanish voice
      language = 'es-ES',
      format = 'mp3',
      speed = 1.0,
      pitch = 0
    } = options;

    try {
      let audioBuffer;
      
      switch (provider) {
        case 'polly':
          audioBuffer = await this.textToSpeechPolly(text, voice, language, format);
          break;
        case 'google':
          audioBuffer = await this.textToSpeechGoogle(# 🚀 BOTBUILDER ULTIMATE - FUNCIONALIDADES EMPRESARIALES

## 1️⃣ MACHINE LEARNING (NLP)

### 📦 backend/models/Intent.js

```javascript
const mongoose = require('mongoose');

const intentSchema = new mongoose.Schema({
  bot: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Bot',
    required: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  displayName: {
    type: String,
    required: true
  },
  trainingPhrases: [{
    text: String,
    entities: [{
      value: String,
      type: String,
      start: Number,
      end: Number
    }]
  }],
  responses: [{
    text: String,
    language: String,
    variants: [String]
  }],
  parameters: [{
    name: String,
    type: String,
    required: Boolean,
    prompts: [String]
  }],
  contexts: {
    input: [String],
    output: [{
      name: String,
      lifespan: Number
    }]
  },
  priority: {
    type: Number,
    default: 0
  },
  mlProvider: {
    type: String,
    enum: ['dialogflow', 'wit', 'luis', 'custom'],
    default: 'dialogflow'
  },
  providerId: String,
  confidence: {
    threshold: {
      type: Number,
      default: 0.7
    },
    lastScore: Number
  },
  analytics: {
    hits: {
      type: Number,
      default: 0
    },
    misses: {
      type: Number,
      default: 0
    },
    accuracy: {
      type: Number,
      default: 0
    }
  },
  isActive: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
intentSchema.index({ bot: 1, name: 1 }, { unique: true });
intentSchema.index({ 'analytics.hits': -1 });

module.exports = mongoose.model('Intent', intentSchema);
```

### 📦 backend/models/Entity.js

```javascript
const mongoose = require('mongoose');

const entitySchema = new mongoose.Schema({
  bot: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Bot',
    required: true
  },
  name: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['system', 'custom', 'regexp', 'list'],
    default: 'custom'
  },
  values: [{
    value: String,
    synonyms: [String]
  }],
  regexp: String,
  systemEntity: String, // @sys.number, @sys.date, etc.
  isActive: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

entitySchema.index({ bot: 1, name: 1 }, { unique: true });

module.exports = mongoose.model('Entity', entitySchema);
```

### 📦 backend/services/nlpService.js

```javascript
const dialogflow = require('@google-cloud/dialogflow');
const { Wit } = require('node-wit');
const axios = require('axios');
const Intent = require('../models/Intent');
const Entity = require('../models/Entity');
const natural = require('natural');
const { franc } = require('franc');

class NLPService {
  constructor() {
    this.initializeProviders();
    this.initializeLocalNLP();
  }

  initializeProviders() {
    // Dialogflow
    if (process.env.DIALOGFLOW_PROJECT_ID) {
      this.dialogflowClient = new dialogflow.SessionsClient({
        keyFilename: process.env.DIALOGFLOW_KEY_PATH
      });
      this.dialogflowProjectId = process.env.DIALOGFLOW_PROJECT_ID;
    }

    // Wit.ai
    if (process.env.WIT_AI_TOKEN) {
      this.witClient = new Wit({
        accessToken: process.env.WIT_AI_TOKEN
      });
    }

    // Microsoft LUIS
    if (process.env.LUIS_ENDPOINT) {
      this.luisEndpoint = process.env.LUIS_ENDPOINT;
      this.luisKey = process.env.LUIS_KEY;
    }
  }

  initializeLocalNLP() {
    // Initialize Natural NLP for local processing
    this.classifier = new natural.BayesClassifier();
    this.tokenizer = new natural.WordTokenizer();
    this.stemmer = natural.PorterStemmer;
    this.sentiment = new natural.SentimentAnalyzer('Spanish', 
      natural.PorterStemmer, 'afinn');
    
    // TF-IDF for keyword extraction
    this.tfidf = new natural.TfIdf();
  }

  // Detect intent from message
  async detectIntent(botId, message, sessionId, language = 'es') {
    try {
      const bot = await Bot.findById(botId);
      
      // Try ML providers first
      let result = null;
      
      if (bot.nlpProvider === 'dialogflow' && this.dialogflowClient) {
        result = await this.detectIntentDialogflow(bot, message, sessionId, language);
      } else if (bot.nlpProvider === 'wit' && this.witClient) {
        result = await this.detectIntentWit(message);
      } else if (bot.nlpProvider === 'luis' && this.luisEndpoint) {
        result = await this.detectIntentLuis(message);
      }
      
      // Fallback to local NLP
      if (!result || result.confidence < 0.5) {
        result = await this.detectIntentLocal(botId, message, language);
      }

      // Track analytics
      if (result.intent) {
        await this.trackIntentHit(result.intent, result.confidence);
      }

      return result;
    } catch (error) {
      console.error('Error detecting intent:', error);
      return this.getFallbackIntent();
    }
  }

  // Dialogflow integration
  async detectIntentDialogflow(bot, message, sessionId, language) {
    try {
      const sessionPath = this.dialogflowClient.projectAgentSessionPath(
        this.dialogflowProjectId,
        sessionId
      );

      const request = {
        session: sessionPath,
        queryInput: {
          text: {
            text: message,
            languageCode: language
          }
        }
      };

      const responses = await this.dialogflowClient.detectIntent(request);
      const result = responses[0].queryResult;

      return {
        intent: result.intent.displayName,
        confidence: result.intentDetectionConfidence,
        entities: result.parameters.fields,
        response: result.fulfillmentText,
        contexts: result.outputContexts,
        provider: 'dialogflow'
      };
    } catch (error) {
      console.error('Dialogflow error:', error);
      throw error;
    }
  }

  // Wit.ai integration
  async detectIntentWit(message) {
    try {
      const response = await this.witClient.message(message);
      
      const intent = response.intents?.[0];
      const entities = response.entities;

      return {
        intent: intent?.name,
        confidence: intent?.confidence || 0,
        entities: entities,
        provider: 'wit'
      };
    } catch (error) {
      console.error('Wit.ai error:', error);
      throw error;
    }
  }

  // Microsoft LUIS integration
  async detectIntentLuis(message) {
    try {
      const response = await axios.get(this.luisEndpoint, {
        params: {
          'subscription-key': this.luisKey,
          'q': message,
          'verbose': true
        }
      });

      const topIntent = response.data.topScoringIntent;
      
      return {
        intent: topIntent.intent,
        confidence: topIntent.score,
        entities: response.data.entities,
        provider: 'luis'
      };
    } catch (error) {
      console.error('LUIS error:', error);
      throw error;
    }
  }

  // Local NLP processing
  async detectIntentLocal(botId, message, language) {
    try {
      // Load bot intents
      const intents = await Intent.find({ bot: botId, isActive: true });
      
      // Train classifier if needed
      if (!this.classifier.docs || this.classifier.docs.length === 0) {
        await this.trainLocalClassifier(intents);
      }

      // Classify message
      const classification = this.classifier.classify(message);
      const classifications = this.classifier.getClassifications(message);
      
      // Get confidence score
      const confidence = classifications[0]?.value || 0;

      // Extract entities
      const entities = await this.extractEntities(botId, message);

      // Get sentiment
      const sentiment = this.analyzeSentiment(message, language);

      return {
        intent: classification,
        confidence: confidence,
        entities: entities,
        sentiment: sentiment,
        provider: 'local',
        classifications: classifications.slice(0, 3)
      };
    } catch (error) {
      console.error('Local NLP error:', error);
      throw error;
    }
  }

  // Train local classifier
  async trainLocalClassifier(intents) {
    for (const intent of intents) {
      for (const phrase of intent.trainingPhrases) {
        this.classifier.addDocument(phrase.text, intent.name);
      }
    }
    
    this.classifier.train();
  }

  // Extract entities from message
  async extractEntities(botId, message) {
    const entities = await Entity.find({ bot: botId, isActive: true });
    const extracted = [];

    for (const entity of entities) {
      if (entity.type === 'regexp' && entity.regexp) {
        const regex = new RegExp(entity.regexp, 'gi');
        const matches = message.match(regex);
        
        if (matches) {
          extracted.push({
            entity: entity.name,
            value: matches[0],
            type: 'regexp'
          });
        }
      } else if (entity.type === 'list') {
        for (const value of entity.values) {
          const searchTerms = [value.value, ...value.synonyms];
          
          for (const term of searchTerms) {
            if (message.toLowerCase().includes(term.toLowerCase())) {
              extracted.push({
                entity: entity.name,
                value: value.value,
                type: 'list',
                matched: term
              });
              break;
            }
          }
        }
      }
    }

    // Extract system entities
    extracted.push(...this.extractSystemEntities(message));

    return extracted;
  }

  // Extract system entities (numbers, dates, emails, etc.)
  extractSystemEntities(message) {
    const entities = [];

    // Numbers
    const numbers = message.match(/\d+/g);
    if (numbers) {
      numbers.forEach(num => {
        entities.push({
          entity: '@sys.number',
          value: parseInt(num),
          type: 'system'
        });
      });
    }

    // Email
    const emails = message.match(/[\w.-]+@[\w.-]+\.\w+/g);
    if (emails) {
      emails.forEach(email => {
        entities.push({
          entity: '@sys.email',
          value: email,
          type: 'system'
        });
      });
    }

    // Phone
    const phones = message.match(/[\+]?[(]?[0-9]{1,3}[)]?[-\s\.]?[(]?[0-9]{1,4}[)]?[-\s\.]?[0-9]{1,4}[-\s\.]?[0-9]{1,9}/g);
    if (phones) {
      phones.forEach(phone => {
        entities.push({
          entity: '@sys.phone',
          value: phone,
          type: 'system'
        });
      });
    }

    // URL
    const urls = message.match(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g);
    if (urls) {
      urls.forEach(url => {
        entities.push({
          entity: '@sys.url',
          value: url,
          type: 'system'
        });
      });
    }

    return entities;
  }

  // Analyze sentiment
  analyzeSentiment(message, language) {
    const tokens = this.tokenizer.tokenize(message);
    const score = this.sentiment.getSentiment(tokens);
    
    let sentiment = 'neutral';
    if (score > 0.1) sentiment = 'positive';
    else if (score < -0.1) sentiment = 'negative';

    return {
      sentiment,
      score,
      confidence: Math.abs(score)
    };
  }

  // Train custom model
  async trainCustomModel(botId, trainingData) {
    try {
      const intents = await Intent.find({ bot: botId });
      
      // Prepare training data
      const documents = [];
      const labels = [];
      
      for (const intent of intents) {
        for (const phrase of intent.trainingPhrases) {
          documents.push(phrase.text);
          labels.push(intent.name);
        }
      }

      // Train using TensorFlow.js or other ML library
      // This would require additional implementation
      
      return {
        success: true,
        message: 'Model trained successfully',
        accuracy: 0.85
      };
    } catch (error) {
      console.error('Error training model:', error);
      throw error;
    }
  }

  // Track intent analytics
  async trackIntentHit(intentName, confidence) {
    await Intent.findOneAndUpdate(
      { name: intentName },
      {
        $inc: { 'analytics.hits': 1 },
        $set: { 'confidence.lastScore': confidence }
      }
    );
  }

  // Get fallback intent
  getFallbackIntent() {
    return {
      intent: 'fallback',
      confidence: 0,
      response: null,
      provider: 'none'
    };
  }

  // Detect language
  detectLanguage(text) {
    const langCode = franc(text);
    const langMap = {
      'spa': 'es',
      'eng': 'en',
      'por': 'pt',
      'fra': 'fr',
      'deu': 'de',
      'ita': 'it'
    };
    
    return langMap[langCode] || 'es';
  }
}

module.exports = new NLPService();
```

## 2️⃣ MULTI-IDIOMA (i18n)

### 📦 backend/models/Translation.js

```javascript
const mongoose = require('mongoose');

const translationSchema = new mongoose.Schema({
  key: {
    type: String,
    required: true,
    index: true
  },
  namespace: {
    type: String,
    default: 'common'
  },
  translations: {
    es: String,
    en: String,
    pt: String,
    fr: String,
    de: String,
    it: String,
    zh: String,
    ja: String,
    ar: String,
    hi: String
  },
  context: String,
  metadata: {
    category: String,
    tags: [String],
    lastUsed: Date,
    usageCount: {
      type: Number,
      default: 0
    }
  },
  isAutoTranslated: {
    type: Boolean,
    default: false
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Compound index for efficient queries
translationSchema.index({ key: 1, namespace: 1 }, { unique: true });

module.exports = mongoose.model('Translation', translationSchema);
```

### 📦 backend/services/translationService.js

```javascript
const { Translate } = require('@google-cloud/translate').v2;
const Translation = require('../models/Translation');
const Flow = require('../models/Flow');
const axios = require('axios');

class TranslationService {
  constructor() {
    this.initializeProviders();
    this.supportedLanguages = ['es', 'en', 'pt', 'fr', 'de', 'it', 'zh', 'ja', 'ar', 'hi'];
  }

  initializeProviders() {
    // Google Translate
    if (process.env.GOOGLE_TRANSLATE_KEY) {
      this.googleTranslate = new Translate({
        key: process.env.GOOGLE_TRANSLATE_KEY
      });
    }

    // Microsoft Translator
    if (process.env.AZURE_TRANSLATOR_KEY) {
      this.azureEndpoint = 'https://api.cognitive.microsofttranslator.com';
      this.azureKey = process.env.AZURE_TRANSLATOR_KEY;
      this.azureRegion = process.env.AZURE_TRANSLATOR_REGION;
    }

    // DeepL
    if (process.env.DEEPL_API_KEY) {
      this.deeplKey = process.env.DEEPL_API_KEY;
      this.deeplEndpoint = 'https://api.deepl.com/v2/translate';
    }
  }

  // Translate text
  async translate(text, targetLang, sourceLang = 'auto') {
    try {
      // Check cache first
      const cached = await this.getCachedTranslation(text, targetLang, sourceLang);
      if (cached) return cached;

      let translation;

      // Try different providers
      if (this.googleTranslate) {
        translation = await this.translateWithGoogle(text, targetLang, sourceLang);
      } else if (this.azureKey) {
        translation = await this.translateWithAzure(text, targetLang, sourceLang);
      } else if (this.deeplKey) {
        translation = await this.translateWithDeepL(text, targetLang, sourceLang);
      } else {
        // Fallback to libre translate (free)
        translation = await this.translateWithLibre(text, targetLang, sourceLang);
      }

      // Cache translation
      await this.cacheTranslation(text, translation, targetLang, sourceLang);

      return translation;
    } catch (error) {
      console.error('Translation error:', error);
      return text; // Return original text on error
    }
  }

  // Google Translate
  async translateWithGoogle(text, targetLang, sourceLang) {
    const [translation] = await this.googleTranslate.translate(text, {
      from: sourceLang === 'auto' ? undefined : sourceLang,
      to: targetLang
    });
    return translation;
  }

  // Microsoft Azure Translator
  async translateWithAzure(text, targetLang, sourceLang) {
    const response = await axios.post(
      `${this.azureEndpoint}/translate`,
      [{
        text: text
      }],
      {
        params: {
          'api-version': '3.0',
          'from': sourceLang === 'auto' ? undefined : sourceLang,
          'to': targetLang
        },
        headers: {
          'Ocp-Apim-Subscription-Key': this.azureKey,
          'Ocp-Apim-Subscription-Region': this.azureRegion,
          'Content-Type': 'application/json'
        }
      }
    );

    return response.data[0].translations[0].text;
  }

  // DeepL
  async translateWithDeepL(text, targetLang, sourceLang) {
    const response = await axios.post(this.deeplEndpoint, null, {
      params: {
        auth_key: this.deeplKey,
        text: text,
        source_lang: sourceLang === 'auto' ? undefined : sourceLang.toUpperCase(),
        target_lang: targetLang.toUpperCase()
      }
    });

    return response.data.translations[0].text;
  }

  // LibreTranslate (free alternative)
  async translateWithLibre(text, targetLang, sourceLang) {
    const response = await axios.post('https://libretranslate.de/translate', {
      q: text,
      source: sourceLang === 'auto' ? 'auto' : sourceLang,
      target: targetLang,
      format: 'text'
    });

    return response.data.translatedText;
  }

  // Translate entire flow
  async translateFlow(flowId, targetLang) {
    try {
      const flow = await Flow.findById(flowId);
      if (!flow) throw new Error('Flow not found');

      const translatedFlow = JSON.parse(JSON.stringify(flow.toObject()));
      
      // Translate flow name and description
      translatedFlow.name = await this.translate(flow.name, targetLang);
      translatedFlow.description = await this.translate(flow.description, targetLang);

      // Translate nodes
      for (let node of translatedFlow.nodes) {
        if (node.data.content) {
          node.data.content = await this.translate(node.data.content, targetLang);
        }
        if (node.data.label) {
          node.data.label = await this.translate(node.data.label, targetLang);
        }
        
        // Translate options for button/list nodes
        if (node.data.options) {
          for (let option of node.data.options) {
            if (option.label) {
              option.label = await this.translate(option.label, targetLang);
            }
          }
        }

        // Translate form fields
        if (node.data.fields) {
          for (let field of node.data.fields) {
            if (field.label) {
              field.label = await this.translate(field.label, targetLang);
            }
            if (field.placeholder) {
              field.placeholder = await this.translate(field.placeholder, targetLang);
            }
          }
        }
      }

      // Save as new flow with language suffix
      const newFlow = new Flow({
        ...translatedFlow,
        _id: undefined,
        name: `${translatedFlow.name} (${targetLang.toUpperCase()})`,
        originalFlow: flowId,
        language: targetLang
      });

      await newFlow.save();
      return newFlow;
    } catch (error) {
      console.error('Error translating flow:', error);
      throw error;
    }
  }

  // Batch translate
  async batchTranslate(texts, targetLang, sourceLang = 'auto') {
    try {
      const translations = [];
      
      // Process in batches of 100
      const batchSize = 100;
      for (let i = 0; i < texts.length; i += batchSize) {
        const batch = texts.slice(i, i + batchSize);
        const batchTranslations = await Promise.all(
          batch.map(text => this.translate(text, targetLang, sourceLang))
        );
        translations.push(...batchTranslations);
      }

      return translations;
    } catch (error) {
      console.error('Batch translation error:', error);
      throw error;
    }
  }

  // Get cached translation
  async getCachedTranslation(text, targetLang, sourceLang) {
    const key = this.generateCacheKey(text, sourceLang);
    const cached = await Translation.findOne({ key, namespace: 'cache' });
    
    if (cached && cached.translations[targetLang]) {
      // Update usage stats
      await Translation.findByIdAndUpdate(cached._id, {
        $inc: { 'metadata.usageCount': 1 },
        $set: { 'metadata.lastUsed': new Date() }
      });
      
      return cached.translations[targetLang];
    }
    
    return null;
  }

  // Cache translation
  async cacheTranslation(text, translation, targetLang, sourceLang) {
    const key = this.generateCacheKey(text, sourceLang);
    
    await Translation.findOneAndUpdate(
      { key, namespace: 'cache' },
      {
        $set: {
          [`translations.${targetLang}`]: translation,
          [`translations.${sourceLang}`]: text,
          isAutoTranslated: true,
          updatedAt: new Date()
        }
      },
      { upsert: true }
    );
  }

  // Generate cache key
  generateCacheKey(text, lang) {
    const crypto = require('crypto');
    return crypto.createHash('md5')
      .update(`${text}_${lang}`)
      .digest('hex');
  }

  // Get available languages
  async getAvailableLanguages() {
    return this.supportedLanguages.map(code => ({
      code,
      name: this.getLanguageName(code),
      nativeName: this.getNativeLanguageName(code)
    }));
  }

  // Get language name
  getLanguageName(code) {
    const names = {
      'es': 'Spanish',
      'en': 'English', 
      'pt': 'Portuguese',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'zh': 'Chinese',
      'ja': 'Japanese',
      'ar': 'Arabic',
      'hi': 'Hindi'
    };
    return names[code] || code;
  }

  // Get native language name
  getNativeLanguageName(code) {
    const names = {
      'es': 'Español',
      'en': 'English',
      'pt': 'Português',
      'fr': 'Français',
      'de': 'Deutsch',
      'it': 'Italiano',
      'zh': '中文',
      'ja': '日本語',
      'ar': 'العربية',
      'hi': 'हिन्दी'
    };
    return names[code] || code;
  }
}

module.exports = new TranslationService();
```

### 📦 frontend/src/i18n/config.js

```javascript
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

// Import translations
import esTranslations from './locales/es.json';
import enTranslations from './locales/en.json';
import ptTranslations from './locales/pt.json';

i18n
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: {
      es: { translation: esTranslations },
      en: { translation: enTranslations },
      pt: { translation: ptTranslations }
    },
    fallbackLng: 'es',
    debug: false,
    
    interpolation: {
      escapeValue: false
    },

    detection: {
      order: ['localStorage', 'cookie', 'navigator', 'htmlTag'],
      caches: ['localStorage', 'cookie']
    }
  });

export default i18n;
```

## 3️⃣ MARKETPLACE

### 📦 backend/models/MarketplaceItem.js

```javascript
const mongoose = require('mongoose');

const marketplaceItemSchema = new mongoose.Schema({
  type: {
    type: String,
    enum: ['template', 'flow', 'bot', 'integration', 'plugin'],
    required: true
  },
  seller: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true
  },
  category: {
    type: String,
    enum: ['customer-service', 'sales', 'marketing', 'support', 'education', 'healthcare', 'finance', 'other'],
    required: true
  },
  tags: [String],
  images: [{
    url: String,
    caption: String,
    order: Number
  }],
  video: {
    url: String,
    thumbnail: String
  },
  pricing: {
    model: {
      type: String,
      enum: ['free', 'one-time', 'subscription', 'usage-based'],
      required: true
    },
    price: {
      type: Number,
      default: 0
    },
    currency: {
      type: String,
      default: 'USD'
    },
    subscription: {
      interval: {
        type: String,
        enum: ['monthly', 'yearly']
      },
      trialDays: Number
    },
    commission: {
      type: Number,
      default: 0.20 // 20% platform commission
    }
  },
  features: [String],
  requirements: [String],
  compatibility: {
    minVersion: String,
    maxVersion: String,
    platforms: [String]
  },
  stats: {
    downloads: {
      type: Number,
      default: 0
    },
    views: {
      type: Number,
      default: 0
    },
    rating: {
      average: {
        type: Number,
        default: 0,
        min: 0,
        max: 5
      },
      count: {
        type: Number,
        default: 0
      }
    },
    revenue: {
      total: {
        type: Number,
        default: 0
      },
      lastMonth: {
        type: Number,
        default: 0
      }
    }
  },
  reviews: [{
    buyer: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    rating: {
      type: Number,
      min: 1,
      max: 5
    },
    title: String,
    comment: String,
    helpful: {
      yes: {
        type: Number,
        default: 0
      },
      no: {
        type: Number,
        default: 0
      }
    },
    verified: {
      type: Boolean,
      default: false
    },
    createdAt: {
      type: