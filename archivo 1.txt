export default BotDetail;

## üì¶ frontend/src/components/Bots/QRScanner.js

```javascript
import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  CircularProgress,
  Alert,
  Chip
} from '@mui/material';
import {
  QrCode2 as QrIcon,
  CheckCircle as CheckIcon,
  Error as ErrorIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import QRCode from 'react-qr-code';
import io from 'socket.io-client';
import api from '../../services/api';

const QRScanner = ({ botId, botStatus }) => {
  const [qrCode, setQrCode] = useState('');
  const [status, setStatus] = useState(botStatus);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [socket, setSocket] = useState(null);

  useEffect(() => {
    // Connect to Socket.io
    const socketUrl = process.env.REACT_APP_SOCKET_URL || 'http://localhost:3001';
    const newSocket = io(socketUrl);
    
    newSocket.on('connect', () => {
      console.log('Socket connected');
      newSocket.emit('join-bot-room', botId);
    });

    newSocket.on('qr-code', (data) => {
      if (data.qr) {
        setQrCode(data.qr);
      }
    });

    newSocket.on('connection-ready', (data) => {
      if (data.botId === botId) {
        setStatus('connected');
        setQrCode('');
      }
    });

    newSocket.on('bot-status-changed', (data) => {
      if (data.botId === botId) {
        setStatus(data.status);
      }
    });

    setSocket(newSocket);

    return () => {
      if (newSocket) {
        newSocket.disconnect();
      }
    };
  }, [botId]);

  const initializeConnection = async () => {
    setLoading(true);
    setError('');
    
    try {
      const response = await api.post(`/whatsapp/${botId}/initialize`);
      if (response.data.qr) {
        setQrCode(response.data.qr);
      }
    } catch (error) {
      setError(error.response?.data?.error || 'Error al inicializar la conexi√≥n');
    } finally {
      setLoading(false);
    }
  };

  const disconnectBot = async () => {
    setLoading(true);
    setError('');
    
    try {
      await api.post(`/whatsapp/${botId}/disconnect`);
      setStatus('disconnected');
      setQrCode('');
    } catch (error) {
      setError('Error al desconectar el bot');
    } finally {
      setLoading(false);
    }
  };

  const getStatusDisplay = () => {
    switch (status) {
      case 'connected':
        return (
          <Chip
            icon={<CheckIcon />}
            label="Conectado"
            color="success"
            size="large"
          />
        );
      case 'connecting':
        return (
          <Chip
            icon={<CircularProgress size={16} />}
            label="Conectando..."
            color="warning"
            size="large"
          />
        );
      case 'error':
        return (
          <Chip
            icon={<ErrorIcon />}
            label="Error de conexi√≥n"
            color="error"
            size="large"
          />
        );
      default:
        return (
          <Chip
            icon={<QrIcon />}
            label="Desconectado"
            color="default"
            size="large"
          />
        );
    }
  };

  return (
    <Box>
      <Card>
        <CardContent>
          <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
            <Typography variant="h6">
              Conexi√≥n WhatsApp
            </Typography>
            {getStatusDisplay()}
          </Box>

          {error && (
            <Alert severity="error" onClose={() => setError('')} sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          {status === 'disconnected' && !qrCode && (
            <Box textAlign="center" py={4}>
              <Typography variant="body1" color="textSecondary" paragraph>
                El bot no est√° conectado a WhatsApp
              </Typography>
              <Button
                variant="contained"
                startIcon={<QrIcon />}
                onClick={initializeConnection}
                disabled={loading}
              >
                {loading ? <CircularProgress size={24} /> : 'Conectar WhatsApp'}
              </Button>
            </Box>
          )}

          {qrCode && (
            <Box textAlign="center" py={2}>
              <Typography variant="body1" gutterBottom>
                Escanea este c√≥digo QR con WhatsApp
              </Typography>
              <Box 
                sx={{ 
                  backgroundColor: 'white', 
                  p: 2, 
                  display: 'inline-block',
                  borderRadius: 2
                }}
              >
                <QRCode value={qrCode} size={256} />
              </Box>
              <Typography variant="caption" display="block" mt={2} color="textSecondary">
                1. Abre WhatsApp en tu tel√©fono
              </Typography>
              <Typography variant="caption" display="block" color="textSecondary">
                2. Toca Men√∫ o Configuraci√≥n y selecciona "Dispositivos vinculados"
              </Typography>
              <Typography variant="caption" display="block" color="textSecondary">
                3. Toca "Vincular un dispositivo"
              </Typography>
              <Typography variant="caption" display="block" color="textSecondary">
                4. Apunta tu tel√©fono a esta pantalla para escanear el c√≥digo
              </Typography>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={initializeConnection}
                sx={{ mt: 2 }}
                disabled={loading}
              >
                Generar nuevo c√≥digo
              </Button>
            </Box>
          )}

          {status === 'connected' && (
            <Box textAlign="center" py={4}>
              <CheckIcon sx={{ fontSize: 64, color: 'success.main' }} />
              <Typography variant="h6" color="success.main" gutterBottom>
                WhatsApp Conectado
              </Typography>
              <Typography variant="body2" color="textSecondary" paragraph>
                El bot est√° conectado y listo para recibir mensajes
              </Typography>
              <Button
                variant="outlined"
                color="error"
                onClick={disconnectBot}
                disabled={loading}
              >
                Desconectar
              </Button>
            </Box>
          )}

          {status === 'connecting' && (
            <Box textAlign="center" py={4}>
              <CircularProgress size={64} />
              <Typography variant="h6" mt={2}>
                Conectando...
              </Typography>
              <Typography variant="body2" color="textSecondary">
                Por favor, espera mientras se establece la conexi√≥n
              </Typography>
            </Box>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default QRScanner;

## üì¶ frontend/src/components/Flows/FlowList.js

```javascript
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Button,
  Card,
  CardContent,
  CardActions,
  Grid,
  Typography,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  CircularProgress,
  Alert
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  ContentCopy as CopyIcon,
  PlayArrow as PlayIcon
} from '@mui/icons-material';
import api from '../../services/api';

const FlowList = () => {
  const navigate = useNavigate();
  const [flows, setFlows] = useState([]);
  const [loading, setLoading] = useState(true);
  const [createDialog, setCreateDialog] = useState(false);
  const [deleteDialog, setDeleteDialog] = useState(null);
  const [error, setError] = useState('');
  const [newFlow, setNewFlow] = useState({
    name: '',
    description: '',
    trigger: 'keyword',
    keywords: ''
  });

  useEffect(() => {
    fetchFlows();
  }, []);

  const fetchFlows = async () => {
    try {
      const response = await api.get('/flows');
      setFlows(response.data.flows);
    } catch (error) {
      console.error('Error fetching flows:', error);
      setError('Error al cargar los flujos');
    } finally {
      setLoading(false);
    }
  };

  const handleCreateFlow = async () => {
    try {
      const flowData = {
        ...newFlow,
        keywords: newFlow.keywords.split(',').map(k => k.trim()).filter(k => k)
      };
      const response = await api.post('/flows', flowData);
      navigate(`/flows/${response.data.flow._id}`);
    } catch (error) {
      setError(error.response?.data?.error || 'Error al crear el flujo');
    }
  };

  const handleDeleteFlow = async (flowId) => {
    try {
      await api.delete(`/flows/${flowId}`);
      setFlows(flows.filter(flow => flow._id !== flowId));
      setDeleteDialog(null);
    } catch (error) {
      setError('Error al eliminar el flujo');
    }
  };

  const handleDuplicateFlow = async (flowId) => {
    try {
      const response = await api.post(`/flows/${flowId}/duplicate`);
      setFlows([...flows, response.data.flow]);
    } catch (error) {
      setError('Error al duplicar el flujo');
    }
  };

  const getTriggerLabel = (trigger) => {
    switch (trigger) {
      case 'keyword': return 'Palabra clave';
      case 'pattern': return 'Patr√≥n';
      case 'always': return 'Siempre';
      case 'welcome': return 'Bienvenida';
      case 'unknown': return 'Desconocido';
      default: return trigger;
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={4}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">Mis Flujos</Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => setCreateDialog(true)}
        >
          Crear Flujo
        </Button>
      </Box>

      {error && (
        <Alert severity="error" onClose={() => setError('')} sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Grid container spacing={3}>
        {flows.map((flow) => (
          <Grid item xs={12} sm={6} md={4} key={flow._id}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {flow.name}
                </Typography>
                <Typography variant="body2" color="textSecondary" paragraph>
                  {flow.description || 'Sin descripci√≥n'}
                </Typography>
                <Box display="flex" gap={1} flexWrap="wrap">
                  <Chip
                    label={getTriggerLabel(flow.trigger)}
                    size="small"
                    color="primary"
                  />
                  {flow.isActive && (
                    <Chip
                      label="Activo"
                      size="small"
                      color="success"
                    />
                  )}
                </Box>
                {flow.keywords && flow.keywords.length > 0 && (
                  <Typography variant="caption" display="block" mt={1}>
                    Palabras: {flow.keywords.slice(0, 3).join(', ')}
                    {flow.keywords.length > 3 && '...'}
                  </Typography>
                )}
                <Typography variant="caption" display="block" mt={1}>
                  Nodos: {flow.nodes?.length || 0} | 
                  Ejecuciones: {flow.stats?.executions || 0}
                </Typography>
              </CardContent>
              <CardActions>
                <IconButton
                  size="small"
                  onClick={() => navigate(`/flows/${flow._id}`)}
                  title="Editar"
                >
                  <EditIcon />
                </IconButton>
                <IconButton
                  size="small"
                  onClick={() => handleDuplicateFlow(flow._id)}
                  title="Duplicar"
                >
                  <CopyIcon />
                </IconButton>
                <IconButton
                  size="small"
                  onClick={() => setDeleteDialog(flow)}
                  color="error"
                  title="Eliminar"
                >
                  <DeleteIcon />
                </IconButton>
              </CardActions>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Create Flow Dialog */}
      <Dialog open={createDialog} onClose={() => setCreateDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Crear Nuevo Flujo</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Nombre del Flujo"
            fullWidth
            variant="outlined"
            value={newFlow.name}
            onChange={(e) => setNewFlow({ ...newFlow, name: e.target.value })}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="Descripci√≥n (opcional)"
            fullWidth
            variant="outlined"
            multiline
            rows={2}
            value={newFlow.description}
            onChange={(e) => setNewFlow({ ...newFlow, description: e.target.value })}
            sx={{ mb: 2 }}
          />
          <FormControl fullWidth sx={{ mb: 2 }}>
            <InputLabel>Tipo de Activaci√≥n</InputLabel>
            <Select
              value={newFlow.trigger}
              onChange={(e) => setNewFlow({ ...newFlow, trigger: e.target.value })}
            >
              <MenuItem value="keyword">Palabra clave</MenuItem>
              <MenuItem value="pattern">Patr√≥n (RegEx)</MenuItem>
              <MenuItem value="always">Siempre</MenuItem>
              <MenuItem value="welcome">Mensaje de bienvenida</MenuItem>
              <MenuItem value="unknown">Comando desconocido</MenuItem>
            </Select>
          </FormControl>
          {newFlow.trigger === 'keyword' && (
            <TextField
              margin="dense"
              label="Palabras clave (separadas por coma)"
              fullWidth
              variant="outlined"
              value={newFlow.keywords}
              onChange={(e) => setNewFlow({ ...newFlow, keywords: e.target.value })}
              placeholder="hola, ayuda, info"
            />
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCreateDialog(false)}>Cancelar</Button>
          <Button 
            onClick={handleCreateFlow} 
            variant="contained"
            disabled={!newFlow.name}
          >
            Crear y Editar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog open={!!deleteDialog} onClose={() => setDeleteDialog(null)}>
        <DialogTitle>Confirmar Eliminaci√≥n</DialogTitle>
        <DialogContent>
          <Typography>
            ¬øEst√°s seguro de que quieres eliminar el flujo "{deleteDialog?.name}"?
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialog(null)}>Cancelar</Button>
          <Button 
            onClick={() => handleDeleteFlow(deleteDialog._id)} 
            color="error"
            variant="contained"
          >
            Eliminar
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default FlowList;

## üì¶ frontend/src/components/Flows/FlowBuilder.js

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import ReactFlow, {
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
  MarkerType
} from 'react-flow-renderer';
import {
  Box,
  Paper,
  Button,
  TextField,
  Typography,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  IconButton,
  Alert,
  CircularProgress
} from '@mui/material';
import {
  Save as SaveIcon,
  ArrowBack as BackIcon,
  Message as MessageIcon,
  QuestionAnswer as QuestionIcon,
  RadioButtonChecked as ButtonIcon,
  List as ListIcon,
  Timer as DelayIcon,
  CallSplit as ConditionIcon,
  Api as ApiIcon,
  Stop as EndIcon
} from '@mui/icons-material';
import NodeTypes from './NodeTypes';
import api from '../../services/api';

const nodeTypes = {
  messageNode: NodeTypes.MessageNode,
  questionNode: NodeTypes.QuestionNode,
  buttonNode: NodeTypes.ButtonNode,
  conditionNode: NodeTypes.ConditionNode,
  endNode: NodeTypes.EndNode
};

const FlowBuilder = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const [flow, setFlow] = useState(null);
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [loading, setLoading] = useState(!!id);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState('');
  const [selectedNode, setSelectedNode] = useState(null);
  const [drawerOpen, setDrawerOpen] = useState(true);

  const nodeOptions = [
    { type: 'message', label: 'Mensaje', icon: <MessageIcon /> },
    { type: 'question', label: 'Pregunta', icon: <QuestionIcon /> },
    { type: 'button', label: 'Botones', icon: <ButtonIcon /> },
    { type: 'list', label: 'Lista', icon: <ListIcon /> },
    { type: 'delay', label: 'Retraso', icon: <DelayIcon /> },
    { type: 'condition', label: 'Condici√≥n', icon: <ConditionIcon /> },
    { type: 'api', label: 'API', icon: <ApiIcon /> },
    { type: 'end', label: 'Fin', icon: <EndIcon /> }
  ];

  useEffect(() => {
    if (id) {
      fetchFlow();
    } else {
      setLoading(false);
    }
  }, [id]);

  const fetchFlow = async () => {
    try {
      const response = await api.get(`/flows/${id}`);
      const flowData = response.data.flow;
      setFlow(flowData);
      
      // Convert flow nodes to ReactFlow format
      if (flowData.nodes && flowData.nodes.length > 0) {
        const rfNodes = flowData.nodes.map(node => ({
          id: node.id,
          type: `${node.type}Node`,
          position: node.position || { x: 250, y: 100 },
          data: node.data || { label: node.type }
        }));
        setNodes(rfNodes);
      }

      // Convert flow edges to ReactFlow format
      if (flowData.edges && flowData.edges.length > 0) {
        const rfEdges = flowData.edges.map(edge => ({
          ...edge,
          markerEnd: { type: MarkerType.ArrowClosed }
        }));
        setEdges(rfEdges);
      }
    } catch (error) {
      setError('Error al cargar el flujo');
    } finally {
      setLoading(false);
    }
  };

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge({ ...params, markerEnd: { type: MarkerType.ArrowClosed } }, eds)),
    [setEdges]
  );

  const onNodeClick = (event, node) => {
    setSelectedNode(node);
  };

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      const reactFlowBounds = event.target.getBoundingClientRect();
      const type = event.dataTransfer.getData('nodeType');

      if (typeof type === 'undefined' || !type) {
        return;
      }

      const position = {
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      };

      const newNode = {
        id: `${type}_${Date.now()}`,
        type: `${type}Node`,
        position,
        data: { 
          label: `${type} node`,
          content: '',
          type: type
        },
      };

      setNodes((nds) => nds.concat(newNode));
    },
    [setNodes]
  );

  const onDragStart = (event, nodeType) => {
    event.dataTransfer.setData('nodeType', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  const handleSave = async () => {
    setSaving(true);
    setError('');

    try {
      // Convert ReactFlow format to backend format
      const flowData = {
        name: flow?.name || 'Nuevo Flujo',
        description: flow?.description || '',
        trigger: flow?.trigger || 'keyword',
        keywords: flow?.keywords || [],
        nodes: nodes.map(node => ({
          id: node.id,
          type: node.data.type || node.type.replace('Node', ''),
          position: node.position,
          data: node.data
        })),
        edges: edges
      };

      if (id) {
        await api.put(`/flows/${id}`, flowData);
      } else {
        const response = await api.post('/flows', flowData);
        navigate(`/flows/${response.data.flow._id}`);
      }
    } catch (error) {
      setError('Error al guardar el flujo');
    } finally {
      setSaving(false);
    }
  };

  const updateNodeData = (nodeId, data) => {
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === nodeId) {
          node.data = { ...node.data, ...data };
        }
        return node;
      })
    );
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={4}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box sx={{ height: 'calc(100vh - 64px)', display: 'flex' }}>
      {/* Node Palette Drawer */}
      <Drawer
        variant="persistent"
        anchor="left"
        open={drawerOpen}
        sx={{
          width: 240,
          '& .MuiDrawer-paper': {
            width: 240,
            position: 'relative',
            height: '100%'
          }
        }}
      >
        <Box p={2}>
          <Typography variant="h6" gutterBottom>
            Nodos Disponibles
          </Typography>
          <List>
            {nodeOptions.map((option) => (
              <ListItem
                key={option.type}
                button
                draggable
                onDragStart={(e) => onDragStart(e, option.type)}
                sx={{
                  cursor: 'grab',
                  mb: 1,
                  border: '1px solid #ddd',
                  borderRadius: 1,
                  '&:hover': {
                    backgroundColor: 'action.hover'
                  }
                }}
              >
                <ListItemIcon>{option.icon}</ListItemIcon>
                <ListItemText primary={option.label} />
              </ListItem>
            ))}
          </List>
        </Box>
      </Drawer>

      {/* Flow Canvas */}
      <Box sx={{ flexGrow: 1, position: 'relative' }}>
        {/* Toolbar */}
        <Paper sx={{ position: 'absolute', top: 10, left: 10, right: 10, zIndex: 10, p: 1 }}>
          <Box display="flex" justifyContent="space-between" alignItems="center">
            <Box display="flex" gap={1}>
              <Button
                variant="outlined"
                startIcon={<BackIcon />}
                onClick={() => navigate('/flows')}
              >
                Volver
              </Button>
              <TextField
                size="small"
                label="Nombre del Flujo"
                value={flow?.name || ''}
                onChange={(e) => setFlow({ ...flow, name: e.target.value })}
              />
            </Box>
            <Button
              variant="contained"
              startIcon={<SaveIcon />}
              onClick={handleSave}
              disabled={saving}
            >
              {saving ? <CircularProgress size={20} /> : 'Guardar'}
            </Button>
          </Box>
        </Paper>

        {error && (
          <Alert 
            severity="error" 
            onClose={() => setError('')}
            sx={{ position: 'absolute', top: 70, left: 10, right: 10, zIndex: 10 }}
          >
            {error}
          </Alert>
        )}

        {/* ReactFlow Canvas */}
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onNodeClick={onNodeClick}
          onDrop={onDrop}
          onDragOver={onDragOver}
          nodeTypes={nodeTypes}
          fitView
        >
          <Controls />
          <MiniMap />
          <Background variant="dots" gap={12} size={1} />
        </ReactFlow>

        {/* Node Properties Panel */}
        {selectedNode && (
          <Paper
            sx={{
              position: 'absolute',
              top: 120,
              right: 10,
              width: 300,
              p: 2,
              zIndex: 10
            }}
          >
            <Typography variant="h6" gutterBottom>
              Propiedades del Nodo
            </Typography>
            <TextField
              fullWidth
              label="Contenido"
              multiline
              rows={4}
              value={selectedNode.data.content || ''}
              onChange={(e) => updateNodeData(selectedNode.id, { content: e.target.value })}
              margin="normal"
            />
            <Button
              variant="outlined"
              fullWidth
              onClick={() => setSelectedNode(null)}
              sx={{ mt: 2 }}
            >
              Cerrar
            </Button>
          </Paper>
        )}
      </Box>
    </Box>
  );
};

export default FlowBuilder;

## üì¶ frontend/src/components/Flows/NodeTypes.js

```javascript
import React from 'react';
import { Handle, Position } from 'react-flow-renderer';
import { Paper, Typography } from '@mui/material';

const nodeStyle = {
  padding: '10px',
  borderRadius: '8px',
  border: '2px solid',
  minWidth: '150px',
  textAlign: 'center'
};

export const MessageNode = ({ data }) => {
  return (
    <Paper style={{ ...nodeStyle, borderColor: '#25D366' }}>
      <Handle type="target" position={Position.Top} />
      <Typography variant="caption">üì© Mensaje</Typography>
      <Typography variant="body2">{data.content || 'Mensaje'}</Typography>
      <Handle type="source" position={Position.Bottom} />
    </Paper>
  );
};

export const QuestionNode = ({ data }) => {
  return (
    <Paper style={{ ...nodeStyle, borderColor: '#128C7E' }}>
      <Handle type="target" position={Position.Top} />
      <Typography variant="caption">‚ùì Pregunta</Typography>
      <Typography variant="body2">{data.content || 'Pregunta'}</Typography>
      <Handle type="source" position={Position.Bottom} />
    </Paper>
  );
};

export const ButtonNode = ({ data }) => {
  return (
    <Paper style={{ ...nodeStyle, borderColor: '#075E54' }}>
      <Handle type="target" position={Position.Top} />
      <Typography variant="caption">üîò Botones</Typography>
      <Typography variant="body2">{data.content || 'Opciones'}</Typography>
      <Handle type="source" position={Position.Bottom} id="a" style={{ left: '30%' }} />
      <Handle type="source" position={Position.Bottom} id="b" style={{ left: '70%' }} />
    </Paper>
  );
};

export const ConditionNode = ({ data }) => {
  return (
    <Paper style={{ ...nodeStyle, borderColor: '#FFA500' }}>
      <Handle type="target" position={Position.Top} />
      <Typography variant="caption">üîÄ Condici√≥n</Typography>
      <Typography variant="body2">{data.condition || 'Si/No'}</Typography>
      <Handle type="source" position={Position.Bottom} id="true" style={{ left: '30%' }} />
      <Handle type="source" position={Position.Bottom} id="false" style={{ left: '70%' }} />
    </Paper>
  );
};

export const EndNode = ({ data }) => {
  return (
    <Paper style={{ ...nodeStyle, borderColor: '#FF0000' }}>
      <Handle type="target" position={Position.Top} />
      <Typography variant="caption">üõë Fin</Typography>
      <Typography variant="body2">{data.content || 'Fin del flujo'}</Typography>
    </Paper>
  );
};

export default {
  MessageNode,
  QuestionNode,
  ButtonNode,
  ConditionNode,
  EndNode
};import React from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import {
  Box,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Divider,
  Chip,
  Typography
} from '@mui/material';
import {
  Dashboard as DashboardIcon,
  SmartToy as BotIcon,
  AccountTree as FlowIcon,
  Settings as SettingsIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';

const Sidebar = ({ mobileOpen, handleDrawerToggle, drawerWidth }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();

  const menuItems = [
    { text: 'Dashboard', icon: <DashboardIcon />, path: '/dashboard' },
    { text: 'Bots', icon: <BotIcon />, path: '/bots' },
    { text: 'Flujos', icon: <FlowIcon />, path: '/flows' },
    { text: 'Configuraci√≥n', icon: <SettingsIcon />, path: '/settings' }
  ];

  const drawer = (
    <div>
      <Toolbar />
      <Divider />
      <List>
        {menuItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton
              selected={location.pathname === item.path}
              onClick={() => navigate(item.path)}
            >
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
      </List>
      <Divider />
      <Box sx={{ p: 2 }}>
        <Typography variant="caption" display="block" gutterBottom>
          Plan Actual
        </Typography>
        <Chip 
          label={user?.plan?.toUpperCase() || 'FREE'} 
          color="primary" 
          size="small" 
        />
        <Box sx={{ mt: 2 }}>
          <Typography variant="caption" display="block">
            Bots: {user?.usage?.currentBots || 0}/{user?.limits?.maxBots || 2}
          </Typography>
          <Typography variant="caption" display="block">
            Flujos: {user?.usage?.currentFlows || 0}/{user?.limits?.maxFlows || 10}
          </Typography>
        </Box>
      </Box>
    </div>
  );

  return (
    <Box
      component="nav"
      sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }}
    >
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={handleDrawerToggle}
        ModalProps={{ keepMounted: true }}
        sx={{
          display: { xs: 'block', sm: 'none' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
        }}
      >
        {drawer}
      </Drawer>
      <Drawer
        variant="permanent"
        sx={{
          display: { xs: 'none', sm: 'block' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
        }}
        open
      >
        {drawer}
      </Drawer>
    </Box>
  );
};

export default Sidebar;

## üì¶ frontend/src/components/Dashboard/Dashboard.js

```javascript
import React, { useState, useEffect } from 'react';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Box,
  LinearProgress,
  Paper
} from '@mui/material';
import {
  SmartToy as BotIcon,
  AccountTree as FlowIcon,
  Message as MessageIcon,
  TrendingUp as TrendingIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import api from '../../services/api';

const Dashboard = () => {
  const { user } = useAuth();
  const [stats, setStats] = useState({
    totalBots: 0,
    activeBots: 0,
    totalFlows: 0,
    totalMessages: 0
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchStats();
  }, []);

  const fetchStats = async () => {
    try {
      const [botsRes, flowsRes] = await Promise.all([
        api.get('/bots'),
        api.get('/flows')
      ]);

      const bots = botsRes.data.bots;
      const flows = flowsRes.data.flows;

      setStats({
        totalBots: bots.length,
        activeBots: bots.filter(b => b.status === 'connected').length,
        totalFlows: flows.length,
        totalMessages: bots.reduce((acc, bot) => acc + (bot.metrics?.totalMessages || 0), 0)
      });
    } catch (error) {
      console.error('Error fetching stats:', error);
    } finally {
      setLoading(false);
    }
  };

  const StatCard = ({ title, value, icon, color, limit }) => (
    <Card>
      <CardContent>
        <Box display="flex" alignItems="center" justifyContent="space-between">
          <Box>
            <Typography color="textSecondary" gutterBottom variant="body2">
              {title}
            </Typography>
            <Typography variant="h4">
              {value}
              {limit && (
                <Typography component="span" variant="body2" color="textSecondary">
                  /{limit}
                </Typography>
              )}
            </Typography>
          </Box>
          <Box
            sx={{
              backgroundColor: `${color}.100`,
              borderRadius: 2,
              p: 1.5,
              display: 'flex'
            }}
          >
            {React.cloneElement(icon, { sx: { color: `${color}.main`, fontSize: 30 } })}
          </Box>
        </Box>
        {limit && (
          <Box mt={2}>
            <LinearProgress
              variant="determinate"
              value={(value / limit) * 100}
              sx={{
                height: 6,
                borderRadius: 3,
                backgroundColor: `${color}.100`,
                '& .MuiLinearProgress-bar': {
                  backgroundColor: `${color}.main`,
                  borderRadius: 3
                }
              }}
            />
          </Box>
        )}
      </CardContent>
    </Card>
  );

  if (loading) {
    return <LinearProgress />;
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Dashboard
      </Typography>
      <Typography variant="body1" color="textSecondary" gutterBottom>
        Bienvenido de nuevo, {user?.name}
      </Typography>

      <Grid container spacing={3} sx={{ mt: 2 }}>
        <Grid item xs={12} sm={6} md={3}>
          <StatCard
            title="Total de Bots"
            value={stats.totalBots}
            limit={user?.limits?.maxBots}
            icon={<BotIcon />}
            color="primary"
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatCard
            title="Bots Activos"
            value={stats.activeBots}
            icon={<TrendingIcon />}
            color="success"
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatCard
            title="Flujos Creados"
            value={stats.totalFlows}
            limit={user?.limits?.maxFlows}
            icon={<FlowIcon />}
            color="warning"
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatCard
            title="Mensajes Este Mes"
            value={stats.totalMessages}
            limit={user?.limits?.maxMessages}
            icon={<MessageIcon />}
            color="info"
          />
        </Grid>
      </Grid>

      <Grid container spacing={3} sx={{ mt: 2 }}>
        <Grid item xs={12} md={8}>
          <Paper sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              Actividad Reciente
            </Typography>
            <Typography variant="body2" color="textSecondary">
              No hay actividad reciente para mostrar.
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={4}>
          <Paper sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              Tu Plan: {user?.plan?.toUpperCase()}
            </Typography>
            <Box mt={2}>
              <Typography variant="body2" gutterBottom>
                <strong>L√≠mites del Plan:</strong>
              </Typography>
              <Typography variant="body2">
                ‚Ä¢ M√°ximo de Bots: {user?.limits?.maxBots}
              </Typography>
              <Typography variant="body2">
                ‚Ä¢ M√°ximo de Flujos: {user?.limits?.maxFlows}
              </Typography>
              <Typography variant="body2">
                ‚Ä¢ Mensajes por mes: {user?.limits?.maxMessages}
              </Typography>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default Dashboard;

## üì¶ frontend/src/components/Bots/BotList.js

```javascript
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Button,
  Card,
  CardContent,
  CardActions,
  Grid,
  Typography,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  CircularProgress,
  Alert
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Power as PowerIcon,
  PowerOff as PowerOffIcon,
  QrCode as QrCodeIcon
} from '@mui/icons-material';
import api from '../../services/api';

const BotList = () => {
  const navigate = useNavigate();
  const [bots, setBots] = useState([]);
  const [loading, setLoading] = useState(true);
  const [createDialog, setCreateDialog] = useState(false);
  const [deleteDialog, setDeleteDialog] = useState(null);
  const [error, setError] = useState('');
  const [newBot, setNewBot] = useState({
    name: '',
    description: ''
  });

  useEffect(() => {
    fetchBots();
  }, []);

  const fetchBots = async () => {
    try {
      const response = await api.get('/bots');
      setBots(response.data.bots);
    } catch (error) {
      console.error('Error fetching bots:', error);
      setError('Error al cargar los bots');
    } finally {
      setLoading(false);
    }
  };

  const handleCreateBot = async () => {
    try {
      const response = await api.post('/bots', newBot);
      setBots([...bots, response.data.bot]);
      setCreateDialog(false);
      setNewBot({ name: '', description: '' });
    } catch (error) {
      setError(error.response?.data?.error || 'Error al crear el bot');
    }
  };

  const handleDeleteBot = async (botId) => {
    try {
      await api.delete(`/bots/${botId}`);
      setBots(bots.filter(bot => bot._id !== botId));
      setDeleteDialog(null);
    } catch (error) {
      setError('Error al eliminar el bot');
    }
  };

  const handleToggleBot = async (botId) => {
    try {
      const response = await api.post(`/bots/${botId}/toggle`);
      setBots(bots.map(bot => 
        bot._id === botId ? response.data.bot : bot
      ));
    } catch (error) {
      setError('Error al cambiar el estado del bot');
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'connected': return 'success';
      case 'connecting': return 'warning';
      case 'error': return 'error';
      default: return 'default';
    }
  };

  const getStatusText = (status) => {
    switch (status) {
      case 'connected': return 'Conectado';
      case 'connecting': return 'Conectando';
      case 'error': return 'Error';
      default: return 'Desconectado';
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={4}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">Mis Bots</Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => setCreateDialog(true)}
        >
          Crear Bot
        </Button>
      </Box>

      {error && (
        <Alert severity="error" onClose={() => setError('')} sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Grid container spacing={3}>
        exports.sanitizeInput = (input) => {
  if (typeof input !== 'string') return input;
  
  return input
    .trim()
    .replace(/[<>]/g, '') // Remove potential HTML tags
    .substring(0, 1000); // Limit length
};

## üì¶ frontend/Dockerfile

```dockerfile
FROM node:18-alpine as build

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
```

## üì¶ frontend/nginx.conf

```nginx
server {
    listen 3000;
    server_name localhost;
    
    root /usr/share/nginx/html;
    index index.html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://backend:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

## üì¶ frontend/package.json

```json
{
  "name": "botbuilder-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.15.3",
    "@mui/material": "^5.15.3",
    "@mui/x-data-grid": "^6.18.7",
    "axios": "^1.6.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-flow-renderer": "^10.3.17",
    "react-qr-code": "^2.0.12",
    "react-router-dom": "^6.21.1",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.6.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "proxy": "http://localhost:3001"
}
```

## üì¶ frontend/.env.example

```env
REACT_APP_API_URL=http://localhost:3001/api
REACT_APP_SOCKET_URL=http://localhost:3001
```

## üì¶ frontend/public/index.html

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="BotBuilder - Plataforma de creaci√≥n de bots para WhatsApp" />
  <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <title>BotBuilder Platform</title>
</head>
<body>
  <noscript>Necesitas habilitar JavaScript para ejecutar esta aplicaci√≥n.</noscript>
  <div id="root"></div>
</body>
</html>
```

## üì¶ frontend/src/index.js

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

## üì¶ frontend/src/index.css

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

#root {
  height: 100vh;
  width: 100vw;
}

.react-flow__node {
  font-size: 12px;
}

.react-flow__handle {
  width: 8px;
  height: 8px;
}

.react-flow__edge-path {
  stroke-width: 2;
}
```

## üì¶ frontend/src/App.js

```javascript
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { AuthProvider } from './context/AuthContext';
import PrivateRoute from './components/Auth/PrivateRoute';
import Login from './components/Auth/Login';
import Register from './components/Auth/Register';
import Layout from './components/Layout/Layout';
import Dashboard from './components/Dashboard/Dashboard';
import BotList from './components/Bots/BotList';
import BotDetail from './components/Bots/BotDetail';
import FlowBuilder from './components/Flows/FlowBuilder';
import FlowList from './components/Flows/FlowList';

const theme = createTheme({
  palette: {
    primary: {
      main: '#25D366', // WhatsApp green
    },
    secondary: {
      main: '#128C7E',
    },
    background: {
      default: '#f5f5f5',
    },
  },
  typography: {
    fontFamily: 'Roboto, sans-serif',
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        },
      },
    },
  },
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <AuthProvider>
        <Router>
          <Routes>
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route path="/" element={<PrivateRoute><Layout /></PrivateRoute>}>
              <Route index element={<Navigate to="/dashboard" />} />
              <Route path="dashboard" element={<Dashboard />} />
              <Route path="bots" element={<BotList />} />
              <Route path="bots/:id" element={<BotDetail />} />
              <Route path="flows" element={<FlowList />} />
              <Route path="flows/new" element={<FlowBuilder />} />
              <Route path="flows/:id" element={<FlowBuilder />} />
            </Route>
          </Routes>
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App;
```

## üì¶ frontend/src/App.css

```css
.App {
  text-align: center;
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}
```

## üì¶ frontend/src/context/AuthContext.js

```javascript
import React, { createContext, useState, useContext, useEffect } from 'react';
import { login as apiLogin, register as apiRegister, getMe } from '../services/auth';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      loadUser();
    } else {
      setLoading(false);
    }
  }, []);

  const loadUser = async () => {
    try {
      const response = await getMe();
      setUser(response.data.user);
    } catch (error) {
      console.error('Error loading user:', error);
      localStorage.removeItem('token');
    } finally {
      setLoading(false);
    }
  };

  const login = async (email, password) => {
    try {
      setError(null);
      const response = await apiLogin(email, password);
      const { token, user } = response.data;
      
      localStorage.setItem('token', token);
      setUser(user);
      
      return { success: true };
    } catch (error) {
      const message = error.response?.data?.error || 'Error al iniciar sesi√≥n';
      setError(message);
      return { success: false, error: message };
    }
  };

  const register = async (name, email, password) => {
    try {
      setError(null);
      const response = await apiRegister(name, email, password);
      const { token, user } = response.data;
      
      localStorage.setItem('token', token);
      setUser(user);
      
      return { success: true };
    } catch (error) {
      const message = error.response?.data?.error || 'Error al registrarse';
      setError(message);
      return { success: false, error: message };
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{
      user,
      loading,
      error,
      login,
      register,
      logout,
      loadUser
    }}>
      {children}
    </AuthContext.Provider>
  );
};
```

## üì¶ frontend/src/services/api.js

```javascript
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor to add token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error## üì¶ backend/middleware/auth.js

```javascript
const jwt = require('jsonwebtoken');
const config = require('../config/config');

module.exports = (req, res, next) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ 
        error: 'No token provided' 
      });
    }

    const token = authHeader.substring(7);

    // Verify token
    const decoded = jwt.verify(token, config.jwt.secret);
    
    // Add user id to request
    req.userId = decoded.userId;
    
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ 
        error: 'Token has expired' 
      });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ 
        error: 'Invalid token' 
      });
    }
    
    return res.status(500).json({ 
      error: 'Server error during authentication' 
    });
  }
};

## üì¶ backend/middleware/errorHandler.js

```javascript
module.exports = (err, req, res, next) => {
  console.error('Error handler:', err);

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      error: 'Validation error',
      details: errors
    });
  }

  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyPattern)[0];
    return res.status(400).json({
      error: `${field} already exists`
    });
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      error: 'Invalid token'
    });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      error: 'Token expired'
    });
  }

  // Default error
  res.status(err.status || 500).json({
    error: err.message || 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

## üì¶ backend/routes/auth.js

```javascript
const router = require('express').Router();
const { body } = require('express-validator');
const authController = require('../controllers/authController');
const auth = require('../middleware/auth');

// Validation rules
const registerValidation = [
  body('name').trim().notEmpty().withMessage('Name is required'),
  body('email').isEmail().normalizeEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters')
];

const loginValidation = [
  body('email').isEmail().normalizeEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required')
];

const changePasswordValidation = [
  body('currentPassword').notEmpty().withMessage('Current password is required'),
  body('newPassword').isLength({ min: 6 }).withMessage('New password must be at least 6 characters')
];

// Routes
router.post('/register', registerValidation, authController.register);
router.post('/login', loginValidation, authController.login);
router.get('/me', auth, authController.getMe);
router.put('/profile', auth, authController.updateProfile);
router.post('/change-password', auth, changePasswordValidation, authController.changePassword);

module.exports = router;

## üì¶ backend/routes/bots.js

```javascript
const router = require('express').Router();
const { body } = require('express-validator');
const botController = require('../controllers/botController');
const auth = require('../middleware/auth');

// Validation rules
const createBotValidation = [
  body('name').trim().notEmpty().withMessage('Bot name is required'),
  body('description').optional().trim()
];

// Routes
router.get('/', auth, botController.getBots);
router.get('/:id', auth, botController.getBot);
router.post('/', auth, createBotValidation, botController.createBot);
router.put('/:id', auth, botController.updateBot);
router.delete('/:id', auth, botController.deleteBot);
router.post('/:id/toggle', auth, botController.toggleBot);

module.exports = router;

## üì¶ backend/routes/flows.js

```javascript
const router = require('express').Router();
const { body } = require('express-validator');
const flowController = require('../controllers/flowController');
const auth = require('../middleware/auth');

// Validation rules
const createFlowValidation = [
  body('name').trim().notEmpty().withMessage('Flow name is required'),
  body('trigger').isIn(['keyword', 'pattern', 'always', 'welcome', 'unknown']).withMessage('Invalid trigger type')
];

// Routes
router.get('/', auth, flowController.getFlows);
router.get('/:id', auth, flowController.getFlow);
router.post('/', auth, createFlowValidation, flowController.createFlow);
router.put('/:id', auth, flowController.updateFlow);
router.delete('/:id', auth, flowController.deleteFlow);
router.post('/:id/duplicate', auth, flowController.duplicateFlow);

module.exports = router;

## üì¶ backend/routes/whatsapp.js

```javascript
const router = require('express').Router();
const { body } = require('express-validator');
const whatsappController = require('../controllers/whatsappController');
const auth = require('../middleware/auth');

// Validation rules
const sendMessageValidation = [
  body('phoneNumber').notEmpty().withMessage('Phone number is required'),
  body('message').notEmpty().withMessage('Message is required')
];

// Routes
router.post('/:botId/initialize', auth, whatsappController.initializeConnection);
router.get('/:botId/qr', auth, whatsappController.getQRCode);
router.post('/:botId/disconnect', auth, whatsappController.disconnect);
router.get('/:botId/status', auth, whatsappController.getStatus);
router.post('/:botId/send-test', auth, sendMessageValidation, whatsappController.sendTestMessage);

module.exports = router;

## üì¶ backend/services/whatsappService.js

```javascript
const makeWASocket = require('@whiskeysockets/baileys').default;
const { useMultiFileAuthState, DisconnectReason, fetchLatestBaileysVersion, makeCacheableSignalKeyStore } = require('@whiskeysockets/baileys');
const pino = require('pino');
const path = require('path');
const fs = require('fs').promises;
const Bot = require('../models/Bot');
const Session = require('../models/Session');
const FlowService = require('./flowService');
const config = require('../config/config');

class WhatsAppService {
  constructor() {
    this.connections = new Map();
    this.reconnectAttempts = new Map();
    this.io = null;
  }

  static getInstance() {
    if (!WhatsAppService.instance) {
      WhatsAppService.instance = new WhatsAppService();
    }
    return WhatsAppService.instance;
  }

  async initializeBot(botId, io) {
    this.io = io;
    
    try {
      // Check if already connected
      if (this.connections.has(botId)) {
        const sock = this.connections.get(botId);
        if (sock.ws && sock.ws.readyState === 1) {
          return { success: true, message: 'Already connected' };
        }
      }

      // Create session directory
      const sessionPath = path.join(config.whatsapp.sessionPath, botId);
      await fs.mkdir(sessionPath, { recursive: true });

      // Load session
      const { state, saveCreds } = await useMultiFileAuthState(sessionPath);
      
      // Get latest version
      const { version } = await fetchLatestBaileysVersion();

      // Create socket
      const sock = makeWASocket({
        version,
        logger: pino({ level: 'silent' }),
        printQRInTerminal: false,
        auth: {
          creds: state.creds,
          keys: makeCacheableSignalKeyStore(state.keys, pino({ level: 'silent' }))
        },
        browser: ['BotBuilder', 'Chrome', '1.0.0'],
        generateHighQualityLinkPreview: true,
        syncFullHistory: false,
        markOnlineOnConnect: true
      });

      // Store connection
      this.connections.set(botId, sock);

      // Handle connection updates
      sock.ev.on('connection.update', async (update) => {
        await this.handleConnectionUpdate(botId, update);
      });

      // Handle credentials update
      sock.ev.on('creds.update', saveCreds);

      // Handle messages
      sock.ev.on('messages.upsert', async (m) => {
        await this.handleIncomingMessages(botId, m);
      });

      // Handle QR code
      return new Promise((resolve) => {
        sock.ev.on('connection.update', (update) => {
          const { qr } = update;
          if (qr) {
            resolve({ success: true, qr });
          }
        });

        // Timeout for QR generation
        setTimeout(() => {
          resolve({ success: true, message: 'Connection initiated' });
        }, 5000);
      });

    } catch (error) {
      console.error(`Error initializing bot ${botId}:`, error);
      throw error;
    }
  }

  async handleConnectionUpdate(botId, update) {
    const { connection, lastDisconnect, qr } = update;
    
    try {
      const bot = await Bot.findById(botId);
      if (!bot) return;

      // Emit QR code to frontend
      if (qr && this.io) {
        this.io.to(`bot-${botId}`).emit('qr-code', { qr });
      }

      // Handle connection states
      if (connection === 'close') {
        const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
        
        if (shouldReconnect) {
          await this.handleReconnect(botId);## üì¶ docker-compose.yml

```yaml
version: '3.8'

services:
  mongodb:
    image: mongo:7.0
    container_name: botbuilder-mongodb
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD:-secretpass}
      MONGO_INITDB_DATABASE: botbuilder
    volumes:
      - mongo_data:/data/db
    networks:
      - botbuilder-network

  redis:
    image: redis:7-alpine
    container_name: botbuilder-redis
    restart: always
    ports:
      - "6379:6379"
    command: redis-server --requirepass ${REDIS_PASSWORD:-redispass}
    volumes:
      - redis_data:/data
    networks:
      - botbuilder-network

  backend:
    build: ./backend
    container_name: botbuilder-backend
    restart: always
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: ${NODE_ENV:-production}
      PORT: 3001
      MONGODB_URI: mongodb://${MONGO_USER:-admin}:${MONGO_PASSWORD:-secretpass}@mongodb:27017/botbuilder?authSource=admin
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redispass}
      JWT_SECRET: ${JWT_SECRET:-your-super-secret-jwt-key}
      CORS_ORIGIN: http://localhost:3000
    depends_on:
      - mongodb
      - redis
    volumes:
      - ./backend:/app
      - /app/node_modules
      - whatsapp_sessions:/app/sessions
    networks:
      - botbuilder-network

  frontend:
    build: ./frontend
    container_name: botbuilder-frontend
    restart: always
    ports:
      - "3000:3000"
    environment:
      REACT_APP_API_URL: http://localhost:3001/api
    depends_on:
      - backend
    volumes:
      - ./frontend:/app
      - /app/node_modules
    networks:
      - botbuilder-network

volumes:
  mongo_data:
  redis_data:
  whatsapp_sessions:

networks:
  botbuilder-network:
    driver: bridge
```

## üì¶ .env.example (ra√≠z)

```env
# MongoDB
MONGO_USER=admin
MONGO_PASSWORD=secretpass

# Redis
REDIS_PASSWORD=redispass

# JWT
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production

# Environment
NODE_ENV=production
```

## üì¶ .gitignore

```gitignore
# Dependencies
node_modules/
package-lock.json
yarn.lock

# Environment variables
.env
.env.local
.env.production

# Build directories
dist/
build/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS files
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo

# Sessions
sessions/
*.session.json

# Docker volumes
mongo_data/
redis_data/
whatsapp_sessions/
```

## üì¶ README.md

```markdown
# BotBuilder Platform

Plataforma completa para crear y gestionar bots de WhatsApp con interfaz visual y m√∫ltiples flujos conversacionales.

## üöÄ Caracter√≠sticas

- ‚úÖ Registro y autenticaci√≥n de usuarios
- ‚úÖ Creaci√≥n visual de flujos conversacionales (drag & drop)
- ‚úÖ Conexi√≥n con WhatsApp mediante QR (Baileys)
- ‚úÖ M√∫ltiples bots por usuario
- ‚úÖ Persistencia de sesiones
- ‚úÖ Reconexi√≥n autom√°tica
- ‚úÖ Panel de administraci√≥n completo

## üìã Requisitos

- Docker y Docker Compose
- Git
- Puerto 3000 y 3001 disponibles

## üõ†Ô∏è Instalaci√≥n

1. Clonar el repositorio:
\`\`\`bash
git clone https://github.com/tu-usuario/botbuilder-platform.git
cd botbuilder-platform
\`\`\`

2. Copiar variables de entorno:
\`\`\`bash
cp .env.example .env
cp backend/.env.example backend/.env
cp frontend/.env.example frontend/.env
\`\`\`

3. Editar los archivos .env con tus configuraciones

4. Construir y levantar los servicios:
\`\`\`bash
docker-compose up -d --build
\`\`\`

## üñ•Ô∏è Acceso

- Frontend: http://localhost:3000
- Backend API: http://localhost:3001/api
- MongoDB: localhost:27017
- Redis: localhost:6379

## üì± Uso

1. Registrarse en la plataforma
2. Crear un nuevo bot
3. Dise√±ar flujos conversacionales
4. Escanear c√≥digo QR para conectar WhatsApp
5. ¬°Listo! Tu bot est√° funcionando

## üîß Comandos √∫tiles

\`\`\`bash
# Ver logs
docker-compose logs -f

# Reiniciar servicios
docker-compose restart

# Detener servicios
docker-compose down

# Detener y eliminar vol√∫menes
docker-compose down -v
\`\`\`

## üìö Stack Tecnol√≥gico

- Frontend: React, Material-UI, React Flow
- Backend: Node.js, Express, Socket.io
- Base de datos: MongoDB, Redis
- WhatsApp: Baileys
- Contenedores: Docker
```

## üì¶ backend/Dockerfile

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

RUN mkdir -p sessions

EXPOSE 3001

CMD ["npm", "start"]
```

## üì¶ backend/package.json

```json
{
  "name": "botbuilder-backend",
  "version": "1.0.0",
  "description": "Backend for BotBuilder Platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "@whiskeysockets/baileys": "^6.5.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-validator": "^7.0.1",
    "ioredis": "^5.3.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.0.3",
    "multer": "^1.4.5-lts.1",
    "pino": "^8.17.2",
    "qrcode": "^1.5.3",
    "socket.io": "^4.6.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

## üì¶ backend/.env.example

```env
# Server
NODE_ENV=development
PORT=3001

# Database
MONGODB_URI=mongodb://admin:secretpass@localhost:27017/botbuilder?authSource=admin

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=redispass

# JWT
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRE=7d

# CORS
CORS_ORIGIN=http://localhost:3000

# WhatsApp
SESSION_PATH=./sessions
```

## üì¶ backend/server.js

```javascript
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { createServer } = require('http');
const { Server } = require('socket.io');
const connectDB = require('./config/database');
const { connectRedis } = require('./config/redis');
const errorHandler = require('./middleware/errorHandler');

// Load environment variables
dotenv.config();

// Initialize Express app
const app = express();
const httpServer = createServer(app);

// Initialize Socket.io
const io = new Server(httpServer, {
  cors: {
    origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
    methods: ['GET', 'POST']
  }
});

// Make io accessible throughout the app
app.set('io', io);

// Middleware
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/bots', require('./routes/bots'));
app.use('/api/flows', require('./routes/flows'));
app.use('/api/whatsapp', require('./routes/whatsapp'));

// Health check
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    services: {
      mongodb: mongoose.connection.readyState === 1,
      redis: global.redisClient?.status === 'ready'
    }
  });
});

// Error handler
app.use(errorHandler);

// Socket.io connections
io.on('connection', (socket) => {
  console.log('New WebSocket connection:', socket.id);
  
  socket.on('join-bot-room', (botId) => {
    socket.join(`bot-${botId}`);
    console.log(`Socket ${socket.id} joined room bot-${botId}`);
  });
  
  socket.on('disconnect', () => {
    console.log('WebSocket disconnected:', socket.id);
  });
});

// Start server
const PORT = process.env.PORT || 3001;

const startServer = async () => {
  try {
    // Connect to MongoDB
    await connectDB();
    console.log('‚úÖ MongoDB connected');
    
    // Connect to Redis
    await connectRedis();
    console.log('‚úÖ Redis connected');
    
    // Start listening
    httpServer.listen(PORT, () => {
      console.log(`üöÄ Server running on port ${PORT}`);
      console.log(`üì° WebSocket server ready`);
    });
  } catch (error) {
    console.error('‚ùå Server startup error:', error);
    process.exit(1);
  }
};

startServer();

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  console.error('Unhandled Promise Rejection:', err);
  // Close server & exit process
  httpServer.close(() => process.exit(1));
});
```

## üì¶ backend/config/database.js

```javascript
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    
    console.log(`MongoDB Connected: ${conn.connection.host}`);
    
    // Handle connection events
    mongoose.connection.on('error', (err) => {
      console.error('MongoDB connection error:', err);
    });
    
    mongoose.connection.on('disconnected', () => {
      console.warn('MongoDB disconnected');
    });
    
    return conn;
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
};

module.exports = connectDB;
```

## üì¶ backend/config/redis.js

```javascript
const Redis = require('ioredis');

let redisClient = null;

const connectRedis = async () => {
  try {
    redisClient = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: process.env.REDIS_PORT || 6379,
      password: process.env.REDIS_PASSWORD,
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000);
        return delay;
      }
    });
    
    redisClient.on('connect', () => {
      console.log('Redis client connected');
    });
    
    redisClient.on('error', (err) => {
      console.error('Redis client error:', err);
    });
    
    // Test connection
    await redisClient.ping();
    
    // Make redis client globally available
    global.redisClient = redisClient;
    
    return redisClient;
  } catch (error) {
    console.error('Redis connection error:', error);
    throw error;
  }
};

const getRedisClient = () => {
  if (!redisClient) {
    throw new Error('Redis client not initialized');
  }
  return redisClient;
};

module.exports = { connectRedis, getRedisClient };
```

## üì¶ backend/config/config.js

```javascript
module.exports = {
  jwt: {
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: process.env.JWT_EXPIRE || '7d'
  },
  bcrypt: {
    saltRounds: 10
  },
  whatsapp: {
    sessionPath: process.env.SESSION_PATH || './sessions',
    reconnectInterval: 5000,
    maxReconnectAttempts: 5
  },
  redis: {
    sessionTTL: 86400, // 24 hours in seconds
    qrCodeTTL: 300 // 5 minutes in seconds
  }
};
```

## üì¶ backend/models/User.js

```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  plan: {
    type: String,
    enum: ['free', 'basic', 'premium', 'enterprise'],
    default: 'free'
  },
  limits: {
    maxBots: {
      type: Number,
      default: 2
    },
    maxFlows: {
      type: Number,
      default: 10
    },
    maxMessages: {
      type: Number,
      default: 1000
    }
  },
  usage: {
    currentBots: {
      type: Number,
      default: 0
    },
    currentFlows: {
      type: Number,
      default: 0
    },
    messagesThisMonth: {
      type: Number,
      default: 0
    }
  },
  lastLogin: Date,
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// Update timestamps
userSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('User', userSchema);
```

## üì¶ backend/models/Bot.js

```javascript
const mongoose = require('mongoose');

const botSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  phoneNumber: {
    type: String,
    sparse: true
  },
  status: {
    type: String,
    enum: ['disconnected', 'connecting', 'connected', 'error'],
    default: 'disconnected'
  },
  isActive: {
    type: Boolean,
    default: false
  },
  flows: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flow'
  }],
  defaultFlow: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flow'
  },
  settings: {
    welcomeMessage: {
      type: String,
      default: 'Hola! Bienvenido a nuestro servicio automatizado.'
    },
    unknownCommandMessage: {
      type: String,
      default: 'Lo siento, no entiendo ese comando. Por favor, intenta de nuevo.'
    },
    responseDelay: {
      type: Number,
      default: 1000 // milliseconds
    },
    typingDelay: {
      type: Number,
      default: 2000 // milliseconds
    },
    autoRead: {
      type: Boolean,
      default: true
    },
    autoResponse: {
      type: Boolean,
      default: true
    }
  },
  metrics: {
    totalMessages: {
      type: Number,
      default: 0
    },
    totalConversations: {
      type: Number,
      default: 0
    },
    lastActivity: Date
  },
  sessionData: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  lastConnection: Date,
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
botSchema.index({ user: 1 });
botSchema.index({ phoneNumber: 1 });
botSchema.index({ status: 1 });

// Update timestamps
botSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Bot', botSchema);
```

## üì¶ backend/models/Flow.js

```javascript
const mongoose = require('mongoose');

const nodeSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['message', 'question', 'button', 'list', 'media', 'delay', 'condition', 'api', 'end'],
    required: true
  },
  position: {
    x: Number,
    y: Number
  },
  data: {
    label: String,
    content: String,
    options: [mongoose.Schema.Types.Mixed],
    mediaUrl: String,
    mediaType: String,
    delay: Number,
    condition: String,
    apiUrl: String,
    apiMethod: String,
    apiHeaders: mongoose.Schema.Types.Mixed,
    apiBody: mongoose.Schema.Types.Mixed,
    variables: [String]
  }
});

const edgeSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true
  },
  source: {
    type: String,
    required: true
  },
  target: {
    type: String,
    required: true
  },
  sourceHandle: String,
  targetHandle: String,
  label: String,
  condition: String
});

const flowSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  trigger: {
    type: String,
    enum: ['keyword', 'pattern', 'always', 'welcome', 'unknown'],
    default: 'keyword'
  },
  keywords: [{
    type: String,
    lowercase: true,
    trim: true
  }],
  pattern: String,
  nodes: [nodeSchema],
  edges: [edgeSchema],
  variables: [{
    name: String,
    type: String,
    defaultValue: mongoose.Schema.Types.Mixed
  }],
  isActive: {
    type: Boolean,
    default: true
  },
  priority: {
    type: Number,
    default: 0
  },
  stats: {
    executions: {
      type: Number,
      default: 0
    },
    completions: {
      type: Number,
      default: 0
    },
    avgDuration: {
      type: Number,
      default: 0
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
flowSchema.index({ user: 1 });
flowSchema.index({ keywords: 1 });
flowSchema.index({ trigger: 1 });
flowSchema.index({ isActive: 1 });

// Update timestamps
flowSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Flow', flowSchema);
```

## üì¶ backend/models/Session.js

```javascript
const mongoose = require('mongoose');

const sessionSchema = new mongoose.Schema({
  botId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Bot',
    required: true,
    unique: true
  },
  sessionData: {
    type: mongoose.Schema.Types.Mixed,
    required: true
  },
  authInfo: {
    type: mongoose.Schema.Types.Mixed
  },
  phoneNumber: String,
  platform: {
    type: String,
    default: 'whatsapp'
  },
  status: {
    type: String,
    enum: ['active', 'expired', 'revoked'],
    default: 'active'
  },
  lastActivity: {
    type: Date,
    default: Date.now
  },
  expiresAt: {
    type: Date,
    default: () => new Date(+new Date() + 30*24*60*60*1000) // 30 days
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes
sessionSchema.index({ botId: 1 });
sessionSchema.index({ phoneNumber: 1 });
sessionSchema.index({ status: 1 });
sessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Update timestamps
sessionSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  this.lastActivity = Date.now();
  next();
});

module.exports = mongoose.model('Session', sessionSchema);
```

## üì¶ backend/controllers/authController.js

```javascript
const User = require('../models/User');
const { generateToken } = require('../utils/jwt');
const { validationResult } = require('express-validator');

// Register new user
exports.register = async (req, res) => {
  try {
    // Check validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { name, email, password } = req.body;

    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ 
        error: 'User already exists with this email' 
      });
    }

    // Create new user
    const user = new User({
      name,
      email,
      password
    });

    await user.save();

    // Generate token
    const token = generateToken(user._id);

    res.status(201).json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        plan: user.plan
      }
    });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ 
      error: 'Server error during registration' 
    });
  }
};

// Login user
exports.login = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password } = req.body;

    // Find user and include password
    const user = await User.findOne({ email }).select('+password');
    
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({ 
        error: 'Invalid email or password' 
      });
    }

    // Check if user is active
    if (!user.isActive) {
      return res.status(403).json({ 
        error: 'Account is deactivated' 
      });
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    // Generate token
    const token = generateToken(user._id);

    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        plan: user.plan,
        limits: user.limits,
        usage: user.usage
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      error: 'Server error during login' 
    });
  }
};

// Get current user
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.userId).select('-password');
    
    if (!user) {
      return res.status(404).json({ 
        error: 'User not found' 
      });
    }

    res.json({
      success: true,
      user
    });
  } catch (error) {
    console.error('Get me error:', error);
    res.status(500).json({ 
      error: 'Server error fetching user' 
    });
  }
};

// Update user profile
exports.updateProfile = async (req, res) => {
  try {
    const { name, email } = req.body;
    
    const user = await User.findById(req.userId);
    
    if (!user) {
      return res.status(404).json({ 
        error: 'User not found' 
      });
    }

    // Check if email is being changed and is unique
    if (email && email !== user.email) {
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(400).json({ 
          error: 'Email already in use' 
        });
      }
    }

    // Update fields
    if (name)